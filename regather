#!/usr/bin/env perl
# -*- mode: cperl; mode: follow; -*-
#

=head1 NAME

regather - syncrepl consumer to generate config files for different services

=cut

=head1 DESCRIPTION

syncrepl consumer to generate config files for different services

=cut

=head1 OPTIONS

=over 4

=item B<-c | --config>

config file ( mandatory)

=item B<-F | --foreground>

run in foreground

=item B<--colors>

terminal colors are used in foreground debug output

=item B<--ldap-debug>

LDAP debug level
    1   outgoing packets (asn_hexdump).
    2   incoming packets (asn_hexdump).
    4   outgoing packets (asn_dump).
    8   incoming packets (asn_dump).

=item B<-v>

verbosity (incremental)

=item B<-h | --help>

help page

=back

=cut

=head1 METHODS

=cut

use strict;
use warnings;
use diagnostics;
use Pod::Usage qw(pod2usage);
use POSIX;
use Template;
use Sys::Syslog qw(:standard :macros);
use Getopt::Long;
use List::Util qw( uniqstr );
use IPC::Open2;
use File::Temp;
use File::Basename;
use Regather::Config;
use Regather::Logg;

use Net::LDAP;
use Net::LDAP::Constant qw( LDAP_SYNC_REFRESH_ONLY
			    LDAP_SYNC_REFRESH_AND_PERSIST
			    LDAP_SUCCESS
			    LDAP_SYNC_PRESENT
			    LDAP_SYNC_ADD
			    LDAP_SYNC_MODIFY
			    LDAP_SYNC_DELETE
			    LDAP_CONNECT_ERROR
			    LDAP_OPERATIONS_ERROR
			    LDAP_LOCAL_ERROR
			 );
use Net::LDAP::Control::SyncRequest;

use constant SYNST => [ qw( LDAP_SYNC_PRESENT LDAP_SYNC_ADD LDAP_SYNC_MODIFY LDAP_SYNC_DELETE ) ];

my $LL = [ qw( emerg alert crit err warning notice info debug ) ];
my $ts_fmt = "%a %F %T %Z (%z)";

my @DAEMONARGS = ($0, @ARGV);
my $PROGNAM    = fileparse($0);
my $VERSION    = '0.5';

our $v     = 0;
our $fg    = 0;
my $colors = 0;
my $config = '/usr/local/etc/regather.conf';
my $ldap_debug;
my $binddn;
my $bindpw;
my $host;
my $base;

Getopt::Long::Configure("no_ignore_case");
my $get_opt_res =
  GetOptions('F|foreground' => \$fg,
	     'c|config=s'   => \$config,
	     'colors'       => \$colors,
	     'ldap-debug=i' => \$ldap_debug,
	     'H|host=s'     => \$host,
	     'B|base=s'     => \$base,
	     'binddn=s'     => \$binddn,
	     'bindpw=s'     => \$bindpw,
	     'v+'           => \$v,
	     'h|help'       => sub { pod2usage(-exitval => 0, -verbose => 2); exit 0 },
	    );

my $log = new Regather::Logg( prognam    => $PROGNAM,
			      foreground => $fg,
			      colors     => $colors );
$log->logg({ pr => 'info', fm => "Regather::Logg initialized ..." }) if $v > 1;

my $ldap_opts;
$ldap_opts->{uri}    = $host   if defined $host;
$ldap_opts->{base}   = $base   if defined $base;
$ldap_opts->{binddn} = $binddn if defined $binddn;
$ldap_opts->{bindpw} = $bindpw if defined $bindpw;
$log->logg({ pr => 'info', fm => "ldap options provided from CLI:\n%s", ls => [ $ldap_opts ] })
  if keys( %{$ldap_opts} ) && $v > 1;

my $cf = new Regather::Config ( filename  => $config,
			        logger    => $log,
			        add_nodes => { ldap => $ldap_opts },
				verbose   => $v );

if ( ! defined $cf ) {
  $log->logg({ fg => $fg, pr => 'err', fm => "do fix config file ..." });
  pod2usage(-exitval => 2, -sections => [ qw(USAGE) ]);
  exit 1;
}

$log->set_m( $cf->getnode('log')->as_hash );

my @start_tls_options;
if ( $cf->is_set(qw(ldap ssl)) && $cf->get(qw(ldap ssl)) eq 'start_tls') {

  push @start_tls_options,
    capath => $cf->get(qw(ldap tls_cacertdir)) if $cf->is_set(qw(ldap tls_cacertdir));
  push @start_tls_options,
    cafile => $cf->get(qw(ldap tls_cacert))    if $cf->is_set(qw(ldap tls_cacert));

  if ( $cf->is_set(qw(ldap tls_reqcert)) &&
       $cf->get(qw(ldap tls_reqcert)) eq 'none') {
    push @start_tls_options, verify => 'never';
  } elsif ( $cf->is_set(qw(ldap tls_reqcert)) &&
	    $cf->get(qw(ldap tls_reqcert)) eq 'allow') {
    push @start_tls_options, verify => 'optional';
  } elsif ( $cf->is_set(qw(ldap tls_reqcert)) &&
	    $cf->get(qw(ldap tls_reqcert)) eq 'demand'
	   or $cf->get(qw(ldap tls_reqcert)) eq 'hard') {
    push @start_tls_options, verify => 'require';
  } elsif ( $cf->is_set(qw(ldap tls_reqcert)) &&
	    $cf->get(qw(ldap tls_reqcert)) eq 'try') {
    push @start_tls_options, verify => 'optional'; # FIXME: That's wrong
  }
  push @start_tls_options,
    clientcert => $cf->get(qw(ldap tls_cert))      if $cf->is_set(qw(ldap tls_cert));
  push @start_tls_options,
    clientkey => $cf->get(qw(ldap tls_key))        if $cf->is_set(qw(ldap tls_key));
  push @start_tls_options,
    ciphers => $cf->get(qw(ldap tls_cipher_suite)) if $cf->is_set(qw(ldap tls_cipher_suite));

  $log->logg({ pr => 'info', fm => "LDAP strt_tls options:\n %s",
	       ls => [ \@start_tls_options ] }) if $v > 2;
}

my @bind_options;
if ( $cf->is_set(qw(ldap binddn)) ) {
  push @bind_options, $cf->get(qw(ldap binddn));
  push @bind_options, password => $cf->get(qw(ldap bindpw))
    if $cf->is_set(qw(ldap bindpw));
}

$log->logg({ pr => 'info', fm => "Config::Parse object as hash:\n%s",
	     ls => [ $cf->as_hash ] }) if $v > 2;
$log->logg({ pr => 'info', fm => "%s v.%s is starting ...", ls => [ $PROGNAM, $VERSION ] });

our @svc = $cf->names_of('service');

daemonize() if ! $fg;

my $req = Net::LDAP::Control::SyncRequest->new( mode     => LDAP_SYNC_REFRESH_AND_PERSIST,
						critical => 1,
						cookie   => undef, );

our $s;
my $tmp;
my $cfgattrs = [];
my $ldap;
my $mesg;
my @svc_map;
my $ww;

foreach ( @svc ) {
  if ( $cf->is_section('service', $_, 'map', 's') ) {
    @svc_map = values( %{ $cf->getnode('service', $_, 'map', 's')->as_hash } );
    $cfgattrs = [ @{$cfgattrs}, @svc_map ];
  } else {
    @svc_map = ();
  }

  if ( $cf->is_section('service', $_, 'map', 'm') ) {
    @svc_map = values( %{ $cf->getnode('service', $_, 'map', 'm')->as_hash } );
    $cfgattrs = [ @{$cfgattrs}, @svc_map ];
  } else {
    @svc_map = ();
  }

}

my @sysattrs = qw( authorizedService
		   description
		   entryUUID
		   entryCSN
		   createTimestamp
		   creatorsName
		   modifiersName
		   modifyTimestamp );
@{$tmp}   = uniqstr @{$cfgattrs};
$cfgattrs = [ @{$tmp}, @sysattrs, ];


#
## -=== MAIN LOOP =====================================================-
#
while ( 1 ) {
  $ldap = Net::LDAP->new( $cf->get(qw(ldap uri)),
			  version => 3,
			  debug   => $ldap_debug // $cf->get(qw(ldap debug)) // 0, )
    || do {
      print "\nUnable to connect to $cf->get(qw(ldap uri)): $!\n\n";
      exit LDAP_CONNECT_ERROR;
    };

  if ( @start_tls_options ) {
    eval {
      $mesg = $ldap->start_tls( @start_tls_options );
    };
    if ( $@ ) {
      $log->logg({ pr => 'err', fm => "TLS negotiation failed: %s",
		   ls => [ $! ] });
      exit LDAP_CONNECT_ERROR;
    } else {
      $log->logg({ pr => 'info', fm => "TLS negotiation succeeded" }) if $v > 1;
    }
  }

  if ( @bind_options ) {
    $mesg = $ldap->bind( @bind_options );
    if ( $mesg->code ) {
      $log->logg({ pr => 'err', fm => "bind error: %s", ls => [ $mesg->error ] });
      exit $mesg->code;
    }
  }

  $mesg = $ldap->search( base     => $cf->get(qw(ldap base)),
			 scope    => $cf->get(qw(ldap scope)),
			 control  => [ $req ],
			 callback => \&ldap_search_callback,
			 filter   => $cf->get(qw(ldap filter)),
			 attrs    => $cfgattrs,
		       );
  if ( $mesg->code ) {
    $log->logg({ pr => 'err',
		 fm => "LDAP search ERROR...\n% 13s%s\n% 13s%s\n% 13s%s\n% 13s%s\n\n% 13s%s\n% 13s%s\n% 13s%s\n% 13s%s\n\n",
		 ls => [
			 'base: ', $cf->get(qw(ldap base)),
			 'scope: ',$cf->get(qw(ldap scope)),
			 'filter: ', $cf->get(qw(ldap filter)),
			 'attrs: ', join("\n", @{$cfgattrs}),

			 'ERROR: ', $mesg->error_name,
			 'TEXT: ', $mesg->error_text,
			 'DESCRIPTION: ', $mesg->error_desc,
			 'SERVER ERROR: ', $mesg->server_error ] });
    exit $mesg->code;
  } else {
    $log->logg({ pr => 'info',
		 fm => "LDAP search:\n% 13s%s\n% 13s%s\n% 13s%s\n% 13s%s\n\n",
		 ls => [ 'base: ', $cf->get(qw(ldap base)),
			 'scope: ',$cf->get(qw(ldap scope)),
			 'filter: ', $cf->get(qw(ldap filter)),
			 'attrs: ', join("\n", @{$cfgattrs}) ] }) if $v > 2;
  }
}

closelog();

exit 0;

#
## ===================================================================
#

=head2 daemonize

do daemonization of ourselves

=cut

sub daemonize {
  my ( $pid, $fh, $pp, $orphaned_pid_mtime );
  if ( -e $cf->get(qw(core pid_file)) ) {
    open( $fh, "<", $cf->get(qw(core pid_file))) || do {
      die "Can't open $cf->get(qw(core pid_file)) for reading: $!";
      exit 1;
    };
    $pid = <$fh>;
    close($fh) || do {
      print "close $cf->get(qw(core pid_file)) (opened for reading) failed: $!\n\n";
      exit 1;
    };

    if ( kill(0, $pid) ) {
      print "Doing nothing\npidfile $cf->get(qw(core pid_file)) of the proces with pid $pid, exists and the very process is alive\n\n";
      exit 1;
    }

    $orphaned_pid_mtime = strftime( $ts_fmt, localtime( (stat( $cf->get(qw(core pid_file)) ))[9] ));
    if ( unlink $cf->get(qw(core pid_file)) ) {
      $log->logg({ pr => 'debug', fm => "orphaned %s was removed",
	     ls => [ $cf->get(qw(core pid_file)) ] })
	if $v > 0;
    } else {
      $log->logg({ pr => 'err', fm => "orphaned %s (mtime: %s) was not removed: %s",
	     ls => [ $cf->get(qw(core pid_file)), $orphaned_pid_mtime, $! ] });
      exit 2;
    }

    undef $pid;
  }

  $pid = fork();
  die "fork went wrong: $!\n\n" unless defined $pid;
  exit(0) if $pid != 0;

  setsid || do { print "setsid went wrong: $!\n\n"; exit 1; };

  open( $pp, ">", $cf->get(qw(core pid_file))) || do {
    print "Can't open $cf->get(qw(core pid_file)) for writing: $!"; exit 1; };
  print $pp "$$";
  close( $pp ) || do {
    print "close $cf->get(qw(core pid_file)) (opened for writing), failed: $!\n\n"; exit 1; };

  if ( $v > 1 ) {
    open (STDIN,  "</dev/null") || do { print "Can't redirect /dev/null to STDIN\n\n"; exit 1; };
    open (STDOUT, ">/dev/null") || do { print "Can't redirect STDOUT to /dev/null\n\n"; exit 1; };
    open (STDERR, ">&STDOUT")   || do { print "Can't redirect STDERR to STDOUT\n\n"; exit 1; };
  }

  $SIG{HUP}  = sub { $log->logg({ pr => 'warning', fm => "HUP SIG received" });
		     exec('perl', @DAEMONARGS); };
  $SIG{USR1} = sub { $log->logg({ pr => 'warning', fm => "USR1 SIG received" }) };
  $SIG{TERM} = sub { $log->logg({ pr => 'warning', fm => "TERM SIG received" });
		     exit 0;};

  if ( $cf->is_set(qw(core uid)) && $cf->is_set(qw(core gid)) ) {
    setgid ( $cf->get(qw(core gid_number)) ) || do { print "setgid went wrong: $!\n\n"; exit 1; };
    setuid ( $cf->get(qw(core uid_number)) ) || do { print "setuid went wrong: $!\n\n"; exit 1; };
  }

  $log->logg({ pr => 'info', fm => "%s v.%s is started.", ls => [ $PROGNAM, $VERSION ] });
}

sub ldap_search_callback {
  my ( $msg, $obj ) = @_;
  my @controls = $msg->control;
  my $syncstate = scalar @controls ? $controls[0] : undef;
  my ( $s, $st, $tt_vars, $map, $out_file_pfx, $out_file, $tmp_debug_msg, $rdn);

  $log->logg({ pr => 'debug', fm => "syncstate: %s", ls => [ $syncstate ] })
    if $v > 4;
  $log->logg({ pr => 'debug', fm => "object: %s", ls => [ $obj ] })
    if $v > 4;

  if ( defined $obj && $obj->isa('Net::LDAP::Entry') ) {

    $rdn = ( split(/=/, ( split(/,/, $obj->dn) )[0]) )[0];

    if ( defined $syncstate && $syncstate->isa('Net::LDAP::Control::SyncState') ) {
      $st = $syncstate->state;
      if ( $st == LDAP_SYNC_ADD || $st == LDAP_SYNC_MODIFY ) {
	foreach $s ( @svc ) {
	  $log->logg({ pr => 'debug',
		       fm => sprintf("SERVICE PREPROCESS: % 8s; is-there-control-attribute( % 36s) = % 6s; DN: %s",
			       $s,
			       $cf->get('service', $s, 'ctrl_attr'),
			       $obj->exists($cf->get('service', $s, 'ctrl_attr')) ? 'TRUE' : 'FALSE',
			       $obj->dn) })
	    if $v > 2;

	  next if ! $obj->exists($cf->get('service', $s, 'ctrl_attr'));

	  $log->logg({ pr => 'debug', fm => "%s: DN: %s", ls => [ SYNST->[$st], $obj->dn ] });

	  if ( $cf->is_set($s, 'out_file_pfx') && $cf->is_set($s, 'out_file') ) {
	    $out_file_pfx = $obj->get_value($cf->get('service', $s, 'out_file_pfx'));
	    if ( ! -d $out_file_pfx ) {
	      $log->logg({ pr => 'err', fm => "service %s, target directory %s doesn't exist",
		     ls => [ $s, $out_file_pfx ] });
	      next;
	    }
	    $out_file =
	      sprintf("%s/%s%s",
		      $out_file_pfx, $cf->get('service', $s, 'out_file'), $cf->get('service', $s, 'out_ext') // '');
	  } elsif ( ! $cf->is_set($s, 'out_file_pfx') && $cf->is_set($s, 'out_file')) {
	    $out_file =
	      sprintf("%s%s", $cf->get('service', $s, 'out_file'), $cf->get('service', $s, 'out_ext') // '');
	  } elsif ( ! $cf->is_set($s, 'out_file_pfx') && ! $cf->is_set($s, 'out_file')) {
	    $out_file = sprintf("%s%s", $obj->get_value($rdn), $cf->get('service', $s, 'out_ext') // '');
	  }

	  $log->logg({ pr => 'debug', fm => "TT OUTPUT to: %s/%s",
		 ls => [ $out_file_pfx // $cf->get('service', $s, 'out_path'), $out_file ] })
	    if $v > 2;

	  #
	  ## collecting all mapped attributes values
	  #
	  foreach my $i ( ( 'm', 's') ) {
	    if ( $cf->is_set($s, 'map', $i) ) {
	      foreach my $j ( $cf->names_of($s, 'map', $i) ) {
		if ( $j eq 'certificateRevocationList' ) {
		  $tt_vars->{$j} =
		    opensslize({ in => $obj->get_value( $cf->get('service', $s, 'map', $i, $j) ) });
		} else {
		  $tt_vars->{$j} = $obj->get_value( $cf->get('service', $s, 'map', $i, $j) ) // 'NA';
		}
	      }
	    }
	  }

	  $tt_vars->{prog}       = sprintf("%s v.%s", $PROGNAM, $VERSION);
	  $tt_vars->{DN}         = $obj->dn;
	  $tt_vars->{date}       = strftime( $ts_fmt, localtime(time));
	  $tt_vars->{descr}      = $obj->get_value('description')
	    if $obj->exists('description');
	  $tt_vars->{server}     = ( split(/\@/, $obj->get_value('authorizedService')) )[1]
	    if $obj->exists('authorizedService');
	  $tt_vars->{createdby}  =
	    ( split(/=/, ( split(/,/, $obj->get_value('creatorsName')) )[0]) )[1];
	  $tt_vars->{modifiedby} =
	    ( split(/=/, ( split(/,/, $obj->get_value('modifiersName')) )[0]) )[1];

	  ## picking root object RDN
	  foreach ( reverse split(/,/, $obj->dn) ) {
	    next if $_ !~ /^uid=/;
	    $tt_vars->{uid} = ( split(/=/, $_) )[1];
	    last;
	  }

	  my ( $tmp_fh, $tmp_fn );
	  eval {
	    $tmp_fh =
	      File::Temp->new( UNLINK => 0,
			       DIR    => $out_file_pfx // $cf->get('service', $s, 'out_path') );
	  };
	  if ( $@ ) {
	    $log->logg({ pr => 'err',
		   fm => "File::Temp->new( DIR => \"%s\" ) for service \"%s\" error: \"%s\"; we skip this service iteration...",
		   ls => [ $out_file_pfx // $cf->get('service', $s, 'out_path'), $s, $@ ] });
	    next;
	  }

	  $tmp_fn = $tmp_fh->filename;

	  my $tt = Template->new( TRIM        => 1,
				  ABSOLUTE    => 1,
				  RELATIVE    => 1,
				  OUTPUT_PATH => $out_file_pfx // $cf->get('service', $s, 'out_path'),
				  DEBUG       => $fg // $cf->get(qw(core tt_debug)) );

	  $log->logg({ pr => 'err',
		 fm => "Template->new( OUTPUT_PATH => %s ) for service %s error: %s",
		 ls => [ $out_file_pfx // $cf->get('service', $s, 'out_path'), $s, $! ] })
	    if ! defined $tt;

	  $tt->process( sprintf("%s/%s",
				$cf->get(qw(core tt_path)),
				$cf->get('service', $s, 'tt_file')),
				$tt_vars,
				$tmp_fh ) || do {
				  $log->logg({ pr => 'err',
					       fm => "%s .tt process error: %s",
					       ls => [ SYNST->[$st], $tt->error ] });
				  next;
				};

	  close( $tmp_fh ) || do {
	    $log->logg({ pr => 'err',
		   fm => "close file (opened for writing), service %s, failed: %s",
		   ls => [ $s, $! ] });
	    next;
	  };

	  if ( -d $cf->get('service', $s, 'out_path') ) {
	    chdir $cf->get('service', $s, 'out_path') ||
	      $log->logg({ pr => 'err', fm => "chdir to %s failed",
		     ls => [ $cf->get('service', $s, 'out_path') ] });
	  } else {
	    $log->logg({ pr => 'err', fm => "chdir to %s failed, wrong path",
		   ls => [ $cf->get('service', $s, 'out_path') ] });
	  }

	  rename $tmp_fn, $out_file ||
	    $log->logg({ pr => 'err', fm => "rename %s to %s, failed",
		   ls => [ $tmp_fn, $out_file ] });

	  if ( -e $out_file ) {
	    if ( $cf->is_set($s, 'chmod') ) {
	      chmod oct($cf->get('service', $s, 'chmod')), $out_file ||
		$log->logg({ pr => 'err', fm => "chmod for %s failed",
		       ls => [ $out_file ] });
	    } elsif ( $cf->is_set(qw(core chmod)) ) {
	      chmod oct($cf->(qw(core chmod))), $out_file ||
		$log->logg({ pr => 'err', fm => "chmod for %s failed",
		       ls => [ $out_file ] });
	    }

	    if ( $cf->is_set($s, 'chown') ) {
	      chown $obj->get_value('uidNumber'), $obj->get_value('gidNumber'), $out_file ||
		$log->logg({ pr => 'err', fm => "chown ($s:$s) %s failed",
		       ls => [ $obj->get_value('uidNumber'),
			       $obj->get_value('gidNumber'),
			       $out_file ] });
	    }
	  } else {
	    $log->logg({ pr => 'err', fm => "%s disappeared, no such file any more...",
		   ls => [ $out_file ] });
	  }
	}
      } elsif ( $st == LDAP_SYNC_DELETE ) {
	  $log->logg({ pr => 'debug', fm => "%s DN: %s", ls => [ SYNST->[$st], $obj->dn] })
	    if $v > 1;
	  if ( unlink $cf->get('service', $s, 'out_path') . '/' . $out_file ) {
	    $log->logg({ pr => 'debug', fm => "file %s was successfully removed",
		 ls => [ $cf->get('service', $s, 'out_path') . '/' . $out_file ] })
	      if $v > 0;
	  } else {
	    $log->logg({ pr => 'err',
		   fm => "file %s was not removed",
		   ls => [ $cf->get('service', $s, 'out_path') . '/' . $out_file, $! ] });
	  }
	}
    } elsif ( defined $syncstate && $syncstate->isa('Net::LDAP::Control::SyncDone') ) {
      $log->logg({ pr => 'debug', fm => "Received SYNC DONE CONTROL" }) if $v > 1;
    } elsif ( ! defined $syncstate ) {
      $log->logg({ pr => 'warning',
	     fm => "LDAP entry without Sync State control" }) if $v > 1;
    }

    $req->cookie($syncstate->cookie) if $syncstate->cookie;

  } elsif ( defined $obj && $obj->isa('Net::LDAP::Intermediate') ) {
    $req->cookie($obj->{'asn'}->{'refreshDelete'}->{'cookie'});
  }
  elsif ( defined $obj && $obj->isa('Net::LDAP::Reference') ) {
    return;
  }
  else {
    return;
  }
}

sub opensslize {
  my $args = shift;
  my $arg = { cmd     => $args->{cmd}     // 'crl',
	      in      => $args->{in},
	      inform  => $args->{inform}  // 'DER',
	      outform => $args->{outform} // 'PEM'
	    };

  my ( $chin, $chou );
  my $pid = open2($chou, $chin,
		  '/usr/bin/openssl', $arg->{cmd}, '-inform', $arg->{inform}, '-outform', $arg->{outform});

  print $chin $arg->{in};
  waitpid( $pid, 0 );
  my $chst = $? >> 8;
  if ( $chst ) {
    $log->logg({ pr => 'err',
	   fm => "opensslize() error!" }) if $v > 1;
  };
  
  $arg->{res} .= $_ while ( <$chou> );
  
  return $arg->{res};
}

=head1 USAGE

regather <-c regather.conf> [ all other options ]

=cut

=head1 FILES

    /usr/local/etc/regather.d/*.tt templates to generate files from
    /usr/local/etc/regather.conf   config file

    /usr/local/etc/openldap/ldap.conf
    /etc/ldap.conf
    /etc/ldap/ldap.conf
    /etc/openldap/ldap.conf

=head1 CONFIG FILE

=over 4

=item B<services>

is comma delimited names of the services we should process

=item B<ctrl_attr>

is LDAP attribute which is expected to be present in the object for
this configuration section service, in case it is absent we start the
next iteration of the I<services> loop.

=back

=cut
