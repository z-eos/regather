#!/usr/bin/env perl
# -*- mode: cperl; mode: follow; -*-
#

=head1 NAME

regather - syncrepl consumer to generate config files for different services

=cut

=head1 DESCRIPTION

syncrepl consumer to generate config files for different services

=cut

=head1 OPTIONS

=over 4

=item B<-c | --config>

config file ( mandatory)

=item B<-F | --foreground>

run in foreground

=item B<--colors>

terminal colors are used in foreground debug output

=item B<--ldap-debug>

LDAP debug level
    1   outgoing packets (asn_hexdump).
    2   incoming packets (asn_hexdump).
    4   outgoing packets (asn_dump).
    8   incoming packets (asn_dump).

=item B<-v>

verbosity (incremental)

=item B<-h | --help>

help page

=back

=cut

=head1 METHODS

=cut

use strict;
use warnings;
use diagnostics;
use Pod::Usage qw(pod2usage);
use POSIX;
use Template;
use Sys::Syslog qw(:standard :macros);
use Getopt::Long;
use Config::Tiny;
use Data::Printer caller_info => 1, class => { expand => 2 };
use List::Util qw( uniqstr );
use IPC::Open2;
use Try::Tiny;
use File::Temp;

use Net::LDAP;
use Net::LDAP::Constant qw( LDAP_SYNC_REFRESH_ONLY
			    LDAP_SYNC_REFRESH_AND_PERSIST
			    LDAP_SUCCESS
			    LDAP_SYNC_PRESENT 
			    LDAP_SYNC_ADD
			    LDAP_SYNC_MODIFY
			    LDAP_SYNC_DELETE
			    LDAP_OPERATIONS_ERROR
			 );
use Net::LDAP::Control::SyncRequest;

use constant SYNST => [ qw( LDAP_SYNC_PRESENT LDAP_SYNC_ADD LDAP_SYNC_MODIFY LDAP_SYNC_DELETE ) ];

my $LL = [ qw( emerg alert crit err warning notice info debug ) ];

my @DAEMONARGS = ($0, @ARGV);

my $fg      = 0;
my $colors  = 0;
my $verbose = 0;
my $config  = '/usr/local/etc/regather.conf';
my $ldap_debug;

openlog($0, "ndelay,pid");

Getopt::Long::Configure("no_ignore_case");
my $get_opt_res =
  GetOptions('F|foreground' => \$fg,
	     'c|config=s'   => \$config,
	     'colors'       => \$colors,
	     'ldap-debug=i' => \$ldap_debug,
	     'v+'           => \$verbose,
	     'h|help'       => sub { pod2usage(-exitval => 0, -verbose => 2); exit 0 },
	    );

my $cfg = Config::Tiny->read( $config );
pod2usage(-exitval => 2, -sections => [ qw(USAGE) ]) if ! defined $cfg;

logg({ fg => $fg, pr => 'info', fm => np($cfg) }) if $verbose > 2;

cfg_validate($cfg);

if ( ! $fg ) {
  daemonize();
}

my $req = Net::LDAP::Control::SyncRequest->new( mode     => LDAP_SYNC_REFRESH_AND_PERSIST,
						critical => 1,
						cookie   => undef, );

our $s;
my ( $ldap, $mesg, $tmp );

my $cfgattrs = [];
our $s_arr;
@{$s_arr} = grep { $_ if $cfg->{services}->{$_} eq 'yes' } keys(%{$cfg->{services}});

foreach $s ( @{$s_arr} ) {
  $cfgattrs = [ @{$cfgattrs},
		values(%{$cfg->{$s . '_map_s'}}),
		values(%{$cfg->{$s . '_map_m'}}), ];
}
my @sysattrs = qw( authorizedService
		   entryUUID
		   entryCSN
		   createTimestamp
		   creatorsName
		   modifiersName
		   modifyTimestamp );
@{$tmp}   = uniqstr @{$cfgattrs};
$cfgattrs = [ @{$tmp}, @sysattrs, ];

while ( 1 ) {

  $ldap = Net::LDAP->new( $cfg->{_}->{host},
			  # async => 1,
			  debug => $ldap_debug // $cfg->{_}->{ldap_debug} // 0,
			);
  logg({ fg => $fg, pr => 'info',
	 fm => "LDAP search: base: %s; scope: %s; filter: %s; attrs: %s",
	 ls => [ $cfg->{_}->{base},
		 $cfg->{_}->{scope},
		 $cfg->{_}->{filter},
		 join("\n", @{$cfgattrs}) ] })
    if $verbose > 2;

  $mesg = $ldap->search( base     => $cfg->{_}->{base},
			 scope    => $cfg->{_}->{scope},
			 control  => [ $req ],
			 callback => \&searchCallback,
			 filter   => $cfg->{_}->{filter},
			 attrs    => $cfgattrs,
		       );
  if ( $mesg->code ) {
    logg({ fg => $fg, pr => 'info',
	   fm => "LDAP search: base: %s; scope: %s; filter: %s; attrs: %s",
	   ls => [ $mesg->{error_name},
		   $mesg->{error_text},
		   $mesg->{mesg_id},
		   $mesg->dn ] });
  }
}

closelog();

sub cfg_validate {
  my $cfg = shift;
  my $cfg_item;

  my @svc;
  if ( exists $cfg->{services} ) {
    foreach (sort (keys (%{$cfg->{services}}))) {
      push @svc, $_ if $cfg->{services}->{$_} eq 'yes';
    }
  } else {
    print "cfg_validate(): services is a mandatory section, you must provide at least one\n\n";
    exit 2;
  }

  foreach ( @svc ) {
    if ( ! -d $cfg->{$_}->{out_path} ) {
      print "cfg_validate(): service $_ out_path: $cfg->{$_}->{out_path} does not exist\n\n";
      exit 2;
    }
  }

  if ( exists $cfg->{_}->{uid} ) {
    $cfg_item = getpwnam( $cfg->{_}->{uid} );
    if ( defined $cfg_item ) {
      logg({ fg => $fg, pr => 'info',
	     fm => "setuid user %s(%s) confirmed", ls => [ $cfg->{_}->{uid}, $cfg_item ] })
	if $verbose > 1;
      $cfg->{_}->{uid_number} = $cfg_item;
    } else {
      print "cfg_validate(): No user $cfg->{_}->{uid} exist\n\n";
      exit 2;
    }
  }
  if ( exists $cfg->{_}->{gid} ) {
    $cfg_item  = getgrnam( $cfg->{_}->{gid} );
    if ( defined $cfg_item ) {
      logg({ fg => $fg, pr => 'info',
	     fm => "setgid group %s(%s) confirmed", ls => [ $cfg->{_}->{gid}, $cfg_item ] })
	if $verbose > 1;
      $cfg->{_}->{gid_number} = $cfg_item;
    } else {
      print "cfg_validate(): No group $cfg->{_}->{gid} exist\n\n";
      return 1;
    }
  }
}

=head2 daemonize

do daemonization of ourselves

=cut

sub daemonize {
  my $pid;
  if ( -e $cfg->{_}->{pid_file} ) {

    open( my $fh, "<", $cfg->{_}->{pid_file}) ||
      die "Can't open $cfg->{_}->{pid_file} for reading: $!";
    $pid = <$fh>;
    close($fh) ||
      die "close $cfg->{_}->{pid_file} (opened for reading) failed: $!";

    if ( kill(0, $pid) ) {
      print "Doing nothing\npidfile $cfg->{_}->{pid_file} of the proces with pid $pid, exists and the very process is alive\n\n";
      exit 1;
    } else {
      my $orphaned_pid_mtime = get_mtime($cfg->{_}->{pid_file});
      if ( unlink $cfg->{_}->{pid_file} ) {
	logg({ fg => $fg, pr => 'debug', fm => "orphaned pid file was removed" })
	  if $verbose > 0;
      } else {
	logg({ fg => $fg, pr => 'err', fm => "orphaned pid (mtime: %s) file was not removed: %s",
	       ls => [ $orphaned_pid_mtime, $! ] });
	exit 2;
      }
    }
    undef $pid;
  }

  try { $pid = fork(); } catch { die "fork went wrong: $!"; };
  exit(0) if $pid != 0;

  setsid || die "setsid went wrong: $!";

  open( my $pp, ">", $cfg->{_}->{pid_file}) ||
    die "Can't open $cfg->{_}->{pid_file} for writing: $!";
  print $pp "$$";
  close( $pp ) ||
    die "close $cfg->{_}->{pid_file} (opened for writing), failed: $!";

  # open (STDIN,  "</dev/null");
  # open (STDOUT, ">/dev/null");
  # open (STDERR, ">&STDOUT");

  $SIG{HUP}  = sub { logg({ fg => $fg, pr => 'warning', fm => "HUP SIG received" });
		     exec('perl', @DAEMONARGS); };
  $SIG{USR1} = sub { logg({ fg => $fg, pr => 'warning', fm => "USR1 SIG received" }) };
  $SIG{TERM} = sub { logg({ fg => $fg, pr => 'warning', fm => "TERM SIG received" });
		     exit 0;};

  if ( exists $cfg->{_}->{uid} && exists $cfg->{_}->{gid} ) {
    try { setgid ( $cfg->{_}->{gid_number} ) } catch { die "setgid went wrong: $!"};
    try { setuid ( $cfg->{_}->{uid_number} ) } catch { die "setuid went wrong: $!"};
  }
}

=head2 logg

wrapper to log to syslog or stdin. On input it expects hash

    fg => foreground: stdin or syslog
    pr => priority: level[|facility]
    fm => format: sprintf format
    ls => list of values to be sprintf-ed with format fm

=cut

sub logg {
  my $args = shift;
  my $arg = { fg   => $args->{fg} // 0,
	      pr   => $args->{pr} // 'info',
	      pr_s => sprintf("%s|%s",
			      $args->{pr}, $cfg->{_}->{log_facility} // 'CONFIG FILE ERROR'),
	      pr_f => sprintf("<%s:%s> ",
			      $cfg->{_}->{log_facility} // 'CONFIG FILE ERROR', $args->{pr}),
	      fm   => $args->{fm},
	      ls   => $args->{ls}  // [], };

  if ( $arg->{fg} ) {
    $arg->{msg} = sprintf $arg->{pr_f} . $arg->{fm}, @{$args->{ls}};
    p($arg->{msg}, colored => $colors && $fg ? 1 : 0 );
  } else {
    syslog( $arg->{pr_s}, $arg->{pr_f} . $arg->{fm}, @{$arg->{ls}} );
  }
}

sub searchCallback {
  my ( $msg, $obj ) = @_;
  my @controls = $msg->control;
  my $syncstate = scalar @controls ? $controls[0] : undef;
  my $st;
  my ( $tt, $tt_vars, $map, $out_file_pfx, $out_file, $tmp_debug_msg, $rdn);

  logg({ fg => $fg, pr => 'debug', fm => "syncstate: %s", ls => [ np( $syncstate ) ] })
    if $verbose > 3;
  logg({ fg => $fg, pr => 'debug', fm => "object: %s", ls => [ np( $obj ) ] })
    if $verbose > 3;

  if ( defined $obj && $obj->isa('Net::LDAP::Entry') ) {

    $rdn = ( split(/=/, ( split(/,/, $obj->dn) )[0]) )[0];

    if ( defined $syncstate && $syncstate->isa('Net::LDAP::Control::SyncState') ) {
      $st = $syncstate->state;
      if ( $st == LDAP_SYNC_ADD || $st == LDAP_SYNC_MODIFY ) {
	foreach $s ( @{$s_arr} ) {
	  logg({ fg => $fg, pr => 'debug',
		 fm => sprintf("WHICH SERVICE: %s; ctrl_attr %s: %s;DN: %s",
			       $s, $cfg->{$s}->{ctrl_attr},
			       $obj->exists($cfg->{$s}->{ctrl_attr}), $obj->dn) })
	    if $verbose > 2;
	  next if ! $obj->exists($cfg->{$s}->{ctrl_attr});

	  logg({ fg => $fg, pr => 'debug', fm => "%s DN: %s", ls => [ SYNST->[$st], $obj->dn ] })
	    if $verbose > 1;

	  if ( exists $cfg->{$s}->{out_file_pfx} && exists $cfg->{$s}->{out_file} ) {
	    $out_file_pfx = $obj->get_value($cfg->{$s}->{out_file_pfx});
	    if ( ! -d $out_file_pfx ) {
	      logg({ fg => $fg, pr => 'err', fm => "service %s, target directory %s doesn't exist",
		     ls => [ $s, $out_file_pfx ] });
	      next;
	    }
	    $out_file =
	      sprintf("%s/%s%s",
		      $out_file_pfx, $cfg->{$s}->{out_file}, $cfg->{$s}->{out_ext} // '');
	  } elsif ( ! exists $cfg->{$s}->{out_file_pfx} && exists $cfg->{$s}->{out_file}) {
	    $out_file =
	      sprintf("%s%s", $cfg->{$s}->{out_file}, $cfg->{$s}->{out_ext} // '');
	  } elsif ( ! exists $cfg->{$s}->{out_file_pfx} && ! exists $cfg->{$s}->{out_file}) {
	    $out_file = sprintf("%s%s", $obj->get_value($rdn), $cfg->{$s}->{out_ext} // '');
	  }

	  logg({ fg => $fg, pr => 'debug',
		 fm => "TT OUTPUT FILE name: " . $out_file })
	    if $verbose > 2;

	  #
	  ## collecting all mapped attributes values
	  #
	  foreach my $i ( ( 'm', 's') ) {
	    $map = $s . '_map_' . $i;
	    if ( exists $cfg->{$map} ) {
	      foreach my $j (keys ( %{$cfg->{$map}} )) {
		if ( $j eq 'certificateRevocationList' ) {
		  $tt_vars->{$j} = opensslize({ in => $obj->get_value($cfg->{$map}->{$j}) });
		} else {
		  $tt_vars->{$j} = $obj->get_value($cfg->{$map}->{$j}) // 'NA';
		}
	      }
	    }
	  }

	  $tt_vars->{DN}         = $obj->dn;
	  $tt_vars->{date}       = strftime( "%a, %F %T %Z (%z)", localtime(time));
	  $tt_vars->{server}     = ( split(/\@/, $obj->get_value('authorizedService')) )[1]
	    if $obj->exists('authorizedService');
	  $tt_vars->{createdby}  =
	    ( split(/=/, ( split(/,/, $obj->get_value('creatorsName')) )[0]) )[1];
	  $tt_vars->{modifiedby} =
	    ( split(/=/, ( split(/,/, $obj->get_value('modifiersName')) )[0]) )[1];
	  foreach ( reverse split(/,/, $obj->dn) ) {
	    next if $_ !~ /^uid=/;
	    $tt_vars->{uid} = ( split(/=/, $_) )[1];
	    last;
	  }

	  my ( $tmp_fh, $tmp_fn);
	  try {
	    $tmp_fh = File::Temp->new( UNLINK => 0,
				       DIR => $out_file_pfx // $cfg->{$s}->{out_path} );
	    $tmp_fn = $tmp_fh->filename;
	    # my $seclevel = File::Temp->safe_level( File::Temp::HIGH );
	    # if ( $seclevel != File::Temp::HIGH ) {
	    #   print "Could not change to high security level...\n\n";
	    #   exit 2;
	    # }
	  } catch {
	    logg({ fg => $fg, pr => 'err', fm => "File::Temp->new( DIR => %s ) error: %s",
		   ls => [ $out_file_pfx // $cfg->{$s}->{out_path}, $! ] });
	    # return LDAP_OPERATIONS_ERROR;
	    exit 2;
	  };

	  $tt = Template->new( TRIM        => 1,
			       ABSOLUTE    => 1,
			       RELATIVE    => 1,
			       OUTPUT_PATH => $out_file_pfx // $cfg->{$s}->{out_path},
			       DEBUG       => $fg // $cfg->{_}->{tt_debug}, );

	  try {
	    $tt->process( sprintf("%s/%s", $cfg->{_}->{tt_path}, $cfg->{$s}->{tt_file}),
			  $tt_vars,
			  $tmp_fh
			);
	  } catch {
	    logg({ fg => $fg, pr => 'err',
		   fm => "%s .tt process error: %s",
		   ls => [ SYNST->[$st], $tt->error] });
	  };
	  close( $tmp_fh ) ||
	    die "close $tmp_fn (opened for writing) failed: $!";

	  if ( -d $cfg->{$s}->{out_path} ) {
	    chdir $cfg->{$s}->{out_path} ||
	      logg({ fg => $fg, pr => 'err', fm => "chdir to %s failed",
		     ls => [ $cfg->{$s}->{out_path} ] });
	  } else {
	    logg({ fg => $fg, pr => 'err', fm => "chdir to %s failed, wrong path",
		   ls => [ $cfg->{$s}->{out_path} ] });
	  }

	  rename $tmp_fn, $out_file ||
	    logg({ fg => $fg, pr => 'err', fm => "rename %s to %s, failed",
		   ls => [ $tmp_fn, $out_file ] });

	  if ( -e $out_file ) {
	    chmod oct($cfg->{$s}->{chmod}), $out_file ||
	      logg({ fg => $fg, pr => 'err', fm => "chmod for %s failed",
		     ls => [ $out_file ] });
	  } else {
	    logg({ fg => $fg, pr => 'err', fm => "chmod for %s failed, no such file",
		   ls => [ $out_file ] });
	  }
	  
	}
      } elsif ( $st == LDAP_SYNC_DELETE ) {
	  logg({ fg => $fg, pr => 'debug', fm => "%s DN: %s", ls => [ SYNST->[$st], $obj->dn] })
	    if $verbose > 1;
	  if ( unlink $cfg->{$s}->{out_path} . '/' . $out_file ) {
	    logg({ fg => $fg, pr => 'debug', fm => "file %s was successfully removed",
		 ls => [ $cfg->{$s}->{out_path} . '/' . $out_file ] })
	      if $verbose > 0;
	  } else {
	    logg({ fg => $fg, pr => 'err',
		   fm => "file %s was not removed",
		   ls => [ $cfg->{$s}->{out_path} . '/' . $out_file, $! ] });
	  }
	}
    } elsif ( defined $syncstate && $syncstate->isa('Net::LDAP::Control::SyncDone') ) {
      logg({ fg => $fg, pr => 'debug', fm => "Received SYNC DONE CONTROL" }) if $verbose > 1;
    } elsif ( ! defined $syncstate ) {
      logg({ fg => $fg, pr => 'warning',
	     fm => "LDAP entry without Sync State control" }) if $verbose > 1;
    }

    $req->cookie($syncstate->cookie) if $syncstate->cookie;

  } elsif ( defined $obj && $obj->isa('Net::LDAP::Intermediate') ) {
    $req->cookie($obj->{'asn'}->{'refreshDelete'}->{'cookie'});
  }
  elsif ( defined $obj && $obj->isa('Net::LDAP::Reference') ) {
    return;
  }
  else {
    return;
  }
}

sub opensslize {
  my $args = shift;
  my $arg = { cmd     => $args->{cmd}     // 'crl',
	      in      => $args->{in},
	      inform  => $args->{inform}  // 'DER',
	      outform => $args->{outform} // 'PEM'
	    };

  my ( $chin, $chou );
  my $pid = open2($chou, $chin,
		  '/usr/bin/openssl', $arg->{cmd}, '-inform', $arg->{inform}, '-outform', $arg->{outform});

  print $chin $arg->{in};
  waitpid( $pid, 0 );
  my $chst = $? >> 8;
  if ( $chst ) {
    logg({ fg => $fg, pr => 'err',
	   fm => "opensslize() error!" }) if $verbose > 1;
  };
  
  $arg->{res} .= $_ while ( <$chou> );
  
  return $arg->{res};
}

sub get_mtime {
  return strftime("%F %T %Z (%z)", localtime( (stat( shift ))[9] ));
}

exit 0;

=head1 USAGE

regather <-c regather.conf> [ all other options ]

=cut

=head1 FILES

    /usr/local/etc/regather.d/*.tt templates to generate files from
    /usr/local/etc/regather.conf   config file

=head1 CONFIG FILE

=over 4

=item B<services>

is comma delimited names of the services we should process

=item B<ctrl_attr>

is LDAP attribute which is expected to be present in the object for
this configuration section service, in case it is absent we start the
next iteration of the I<services> loop.

=back
