#!/usr/bin/env perl
# -*- mode: cperl; mode: follow; -*-
#

use strict;
use warnings;
use diagnostics;
use POSIX;
use Template;
use Pod::Usage   qw(pod2usage);
use Sys::Syslog  qw(:standard :macros);
use Getopt::Long qw(:config no_ignore_case gnu_getopt auto_version);
use List::Util   qw(uniqstr);
use IPC::Open2;
use File::Temp;
use File::Basename;

use Regather::Config;
use Regather::Logg;

use Net::LDAP;
use Net::LDAP::LDIF;
use Net::LDAP::Constant qw( LDAP_SYNC_REFRESH_ONLY
			    LDAP_SYNC_REFRESH_AND_PERSIST
			    LDAP_SUCCESS
			    LDAP_SYNC_PRESENT
			    LDAP_SYNC_ADD
			    LDAP_SYNC_MODIFY
			    LDAP_SYNC_DELETE
			    LDAP_CONNECT_ERROR
			    LDAP_OPERATIONS_ERROR
			    LDAP_LOCAL_ERROR );
use Net::LDAP::Control::SyncRequest;
use Net::LDAP::Util qw(generalizedTime_to_time);

use constant SYNST => [ qw( LDAP_SYNC_PRESENT LDAP_SYNC_ADD LDAP_SYNC_MODIFY LDAP_SYNC_DELETE ) ];

my @DAEMONARGS = ($0, @ARGV);
my $PROGNAM    = fileparse($0);
our $VERSION    = '0.74';

our $v      = 0;
our $fg     = 0;
our $force  = 0;
our $strict = 0;
my $colors  = 0;
my $config  = '/usr/local/etc/regather.conf';
my $ts_fmt  = "%a %F %T %Z (%z)";
my $cli;
my $ch;

my $get_opt_res =
  GetOptions(
	     'f|foreground' => \$fg,
	     'F|force'     => \$force,
	     'c|config=s'   => \$config,
	     'colors'       => \$colors,
	     'C|cli=s%'     => \$cli,
	     'S|strict'     => \$strict,
	     'config-help'  => \$ch,
	     'v+'           => \$v,
	     'h'            => sub { pod2usage(-exitval => 0, -verbose => 2); exit 0 },
	    );

my $log = new Regather::Logg( prognam    => $PROGNAM,
			      foreground => $fg,
			      colors     => $colors );
$log->cc( pr => 'info', fm => "Regather::Logg initialized ..." ) if $v > 1;

$log->cc( pr => 'info', fm => "options provided from CLI:\n%s", ls => [ $cli ] )
  if keys( %{$cli} ) && $v > 1;

my $cf = new Regather::Config ( filename  => $config,
			        logger    => $log,
				cli       => $cli,
				verbose   => $v );

if ( ! defined $cf ) {
  $log->cc( pr => 'err', fm => "do fix config file ..." );
  pod2usage(-exitval => 2, -sections => [ qw(USAGE) ]);
  exit 1;
}

if ( $ch ) {
  $cf->config_help;
  exit 1;
}

$log->set_m( $cf->getnode('log')->as_hash );

$log->cc( pr => 'info', fm => "Dry Run is set on, no file is to be changed\n" )
  if $cf->get(qw(core dryrun));
$log->cc( pr => 'info', fm => "Config::Parse object as hash:\n%s",
	  ls => [ $cf->as_hash ] ) if $v > 3;
$log->cc( pr => 'info', fm => "%s v.%s is starting ...",
	  ls => [ $PROGNAM, $VERSION, ] );

our @svc = grep { $cf->get('service', $_, 'skip') != 1 } $cf->names_of('service');

daemonize() if ! $fg;

our $s;
our $ldap;
my  $req;
my  $tmp;
our $cfgattrs = [];
my  $mesg;
my  @svc_map;

foreach my $i ( @svc ) {
  foreach ( qw( s m ) ) {
    if ( $cf->is_section('service', $i, 'map', $_) ) {
      @svc_map = values( %{ $cf->getnode('service', $i, 'map', $_)->as_hash } );
      # push @svc_map, $cf->getnode('service', $i, 'ctrl_attr');
      $cfgattrs = [ @{$cfgattrs}, @svc_map, @{$cf->get('service', $i, 'ctrl_attr')} ];
    } else {
      @svc_map = ();
    }
  }
}

@{$tmp} = sort @{[ @{$cfgattrs}, qw( associatedDomain
				     authorizedService
				     description
				     entryUUID
				     entryCSN
				     createTimestamp
				     creatorsName
				     modifiersName
				     modifyTimestamp ) ]};
@{$cfgattrs} = uniqstr @{$tmp};

#
## -=== MAIN LOOP =====================================================-
#

my $ldap_opt      = $cf->getnode(qw(ldap opt))->as_hash;
my $uri           = delete $ldap_opt->{uri};
our $last_forever = 1;
while ( $last_forever ) {
  if ( $cf->is_set(qw(core altroot)) ) {
    chdir($cf->get(qw(core altroot))) || do {
      $log->cc( pr => 'err', fm => "main: unable to chdir to %s",
		ls => [ $cf->get(qw(core altroot)) ] );
      exit 1;
    };
  }

  $ldap = Net::LDAP->new( $uri,
			  @{[ map { $_ => $ldap_opt->{$_} } %$ldap_opt ]} )
    || do {
      $log->cc( pr => 'err', fm => "Unable to connect to %s; error: %s",
		ls => [ $uri, $! ] );
      if ( $strict ) {
	exit LDAP_CONNECT_ERROR;
      } else {
	next;
      }
    };

  my $start_tls_options = $cf->getnode(qw(ldap ssl))->as_hash if $cf->is_section(qw(ldap ssl));
  if ( exists $start_tls_options->{ssl} && $start_tls_options->{ssl} eq 'start_tls' ) {
    delete $start_tls_options->{ssl};
    eval {
      $mesg =
	$ldap->start_tls( @{[ map { $_ => $start_tls_options->{$_} } %$start_tls_options ]} );
    };
    if ( $@ ) {
      $log->cc( pr => 'err', fm => "TLS negotiation failed: %s", ls => [ $! ] );
      if ( $strict ) {
	exit LDAP_CONNECT_ERROR;
      } else {
	next;
      }
    } else {
      $log->cc( pr => 'info', fm => "TLS negotiation succeeded" ) if $v > 1;
    }
  }

  my $bind = $cf->getnode(qw(ldap bnd))->as_hash if $cf->is_section(qw(ldap bnd));
  if ( ref($bind) eq 'HASH' ) {
    if ( exists $bind->{dn} ) {
      my @bind_options;
      push @bind_options, delete $bind->{dn};
      while ( my($k, $v) = each %{$bind} ) {
	push @bind_options, $k => $v;
      }
      $mesg = $ldap->bind( @bind_options );
      if ( $mesg->code ) {
	$log->cc( pr => 'err', fm => "bind error: %s", ls => [ $mesg->error ] );
	if ( $strict ) {
	  exit $mesg->code;
	} else {
	  next;
	}
      }
    }
  }

  $req = Net::LDAP::Control::SyncRequest->new( mode     => LDAP_SYNC_REFRESH_AND_PERSIST,
					       critical => 1,
					       cookie   => undef, );

  $mesg = $ldap->search( base     => $cf->get(qw(ldap srch base)),
			 scope    => $cf->get(qw(ldap srch scope)),
			 control  => [ $req ],
			 callback => \&ldap_search_callback,
			 filter   => $cf->get(qw(ldap srch filter)),
			 attrs    => $cfgattrs,
			 sizelimit=> $cf->get(qw(ldap srch sizelimit)),
			 timelimit=> $cf->get(qw(ldap srch timelimit)),
		       );
  if ( $mesg->code ) {
    $log->cc( pr => 'err',
	      fm => "LDAP search ERROR...\n% 13s%s\n% 13s%s\n% 13s%s\n% 13s%s\n\n",
	      ls => [
		     'base: ',         $cf->get(qw(ldap srch base)),
		     'scope: ',        $cf->get(qw(ldap srch scope)),
		     'filter: ',       $cf->get(qw(ldap srch filter)),
		     'attrs: ',        join("\n", @{$cfgattrs}) ] );
    $log->cc_ldap_err( mesg => $mesg );
    exit $mesg->code if $strict;
  } else {
    $log->cc( pr => 'info',
	      fm => "LDAP search:\n% 13s%s\n% 13s%s\n% 13s%s\n% 13s%s\n\n",
	      ls => [ 'base: ',   $cf->get(qw(ldap srch base)),
		      'scope: ',  $cf->get(qw(ldap srch scope)),
		      'filter: ', $cf->get(qw(ldap srch filter)),
		      'attrs: ',  join("\n", @{$cfgattrs}) ] ) if $v > 2;
  }
}

$mesg = $ldap->unbind;
if ( $mesg->code ) {
  $log->cc_ldap_err( mesg => $mesg );
  exit $mesg->code;
}

closelog();

exit 0;

#
## ===================================================================
#

sub daemonize {
  my ( $pid, $fh, $pp, $orphaned_pid_mtime );
  if ( -e $cf->get(qw(core pid_file)) ) {
    open( $fh, "<", $cf->get(qw(core pid_file))) || do {
      die "Can't open $cf->get(qw(core pid_file)) for reading: $!";
      exit 1;
    };
    $pid = <$fh>;
    close($fh) || do {
      print "close $cf->get(qw(core pid_file)) (opened for reading) failed: $!\n\n";
      exit 1;
    };

    if ( kill(0, $pid) ) {
      print "Doing nothing\npidfile $cf->get(qw(core pid_file)) of the proces with pid $pid, exists and the very process is alive\n\n";
      exit 1;
    }

    $orphaned_pid_mtime = strftime( $ts_fmt, localtime( (stat( $cf->get(qw(core pid_file)) ))[9] ));
    if ( unlink $cf->get(qw(core pid_file)) ) {
      $log->cc( pr => 'debug', fm => "orphaned %s was removed",
		ls => [ $cf->get(qw(core pid_file)) ] )
	if $v > 0;
    } else {
      $log->cc( pr => 'err', fm => "orphaned %s (mtime: %s) was not removed: %s",
		ls => [ $cf->get(qw(core pid_file)), $orphaned_pid_mtime, $! ] );
      exit 2;
    }

    undef $pid;
  }

  $pid = fork();
  die "fork went wrong: $!\n\n" unless defined $pid;
  exit(0) if $pid != 0;

  setsid || do { print "setsid went wrong: $!\n\n"; exit 1; };

  open( $pp, ">", $cf->get(qw(core pid_file))) || do {
    print "Can't open $cf->get(qw(core pid_file)) for writing: $!"; exit 1; };
  print $pp "$$";
  close( $pp ) || do {
    print "close $cf->get(qw(core pid_file)) (opened for writing), failed: $!\n\n"; exit 1; };

  if ( $v > 1 ) {
    open (STDIN,  "</dev/null") || do { print "Can't redirect /dev/null to STDIN\n\n"; exit 1; };
    open (STDOUT, ">/dev/null") || do { print "Can't redirect STDOUT to /dev/null\n\n"; exit 1; };
    open (STDERR, ">&STDOUT")   || do { print "Can't redirect STDERR to STDOUT\n\n"; exit 1; };
  }

  $SIG{HUP}  = sub { my $sig = @_;
		     $log->cc( pr => 'warning', fm => "SIG $sig received, restarting" );
		     exec('perl', @DAEMONARGS); };
  $SIG{INT} = $SIG{QUIT} = $SIG{ABRT} = $SIG{TERM} =
    sub { my $sig = @_;
	  $log->cc( pr => 'warning', fm => " SIG $sig received, exiting" );
	  $last_forever = 0;};
  $SIG{PIPE} = 'ignore';
  $SIG{USR1} = sub { my $sig = @_;
		     $log->cc( pr => 'warning', fm => "SIG $sig received, doing nothing" ) };

  if ( $cf->is_set(qw(core uid)) && $cf->is_set(qw(core gid)) ) {
    setgid ( $cf->get(qw(core gid_number)) ) || do { print "setgid went wrong: $!\n\n"; exit 1; };
    setuid ( $cf->get(qw(core uid_number)) ) || do { print "setuid went wrong: $!\n\n"; exit 1; };
  }

  $log->cc( pr => 'info', fm => "%s v.%s is started.", ls => [ $PROGNAM, $VERSION ] );
}

sub ldap_search_callback {
  my ( $msg, $obj ) = @_;

  my @controls = $msg->control;
  my $syncstate = scalar @controls ? $controls[0] : undef;

  my ( $s, $st, $mesg, $entry, @entries, $ldif, $tt_vars, $map,
       %out_paths, $out_file_pfx, $out_file, $out_file_pfx_old, $out_file_old,
       $tmp_debug_msg,
       $rdn, $rdn_old, $rdn_re,
       $dir );

  $log->cc( pr => 'debug', fm => "syncstate: %s", ls => [ $syncstate ] )
    if $v > 5;
  $log->cc( pr => 'debug', fm => "object: %s", ls => [ $obj ] ) if $v > 5;

  if ( defined $obj && $obj->isa('Net::LDAP::Entry') ) {
    $rdn = ( split(/=/, ( split(/,/, $obj->dn) )[0]) )[0];
    if ( defined $syncstate && $syncstate->isa('Net::LDAP::Control::SyncState') ) {
      $log->cc( pr => 'debug', fm => "SYNCSTATE:\n%s:", ls => [ $syncstate ] )
	if $v > 4;
      $st = $syncstate->state;
      my %reqmod;
      $log->cc( fm => "received control %s: dn: %s", ls => [ SYNST->[$st], $obj->dn ] );

      ### discovering a service, $obj relates to
      my $is_ctrl_attr;
      my $ctrl_srv_re;
      foreach ( @svc ) {
	$is_ctrl_attr = 0;
	foreach my $ctrl_attr ( @{$cf->get('service', $_, 'ctrl_attr')} ) {
	  if ( $obj->exists( $ctrl_attr ) ) {
	    $is_ctrl_attr++;
	  } else {
	    $is_ctrl_attr--;
	  }
	}
	$ctrl_srv_re = $cf->get('service', $_, 'ctrl_srv_re');
	if ( $is_ctrl_attr > 0 &&
	     $is_ctrl_attr == scalar( @{$cf->get('service', $_, 'ctrl_attr')} ) &&
	     $obj->dn =~ qr/$ctrl_srv_re/ ) {
	  $s = $_;
	}
      }

      ### LDAP_SYNC_DELETE arrives for both cases, object deletetion
      ### and attribute deletion and in both cases Net::LDAP::Entry
      ### provided contains only DN, so, we need to "re-construct"
      ### it for further processing
      if ( $st == LDAP_SYNC_DELETE ) {
	$mesg = $ldap->search( base     => $cf->get(qw(ldap srch log_base)),
			       scope    => 'sub',
			       sizelimit=> $cf->get(qw(ldap srch sizelimit)),
			       timelimit=> $cf->get(qw(ldap srch timelimit)),
			       filter   => '(reqDN=' . $obj->dn . ')', );
	if ( $mesg->code ) {
	  $log->cc( pr => 'err',
		    fm => "LDAP accesslog search on %s, error:\n% 13s%s\n% 13s%s\n% 13s%s\n\n",
		    ls => [ SYNST->[$st],
			    'base: ',   $cf->get(qw(ldap srch log_base)),
			    'scope: ',  'sub',
			    'filter: ', '(reqDN=' . $obj->dn . ')' ] );
	  $log->cc_ldap_err( mesg => $mesg );
	  # exit $mesg->code; # !!! NEED TO DECIDE WHAT TO DO
	} else {
	  $entry = pop @{[$mesg->sorted]};

	  if ( $entry->get_value('reqType') eq 'delete' ) {
	    my $reqold = 'dn: ' . $obj->dn;
	    foreach ( @{$entry->get_value('reqOld', asref => 1)} ) {
	      s/^(.*;binary:) .*$/$1: c3R1Yg==/agis;
	      $reqold .= "\n" . $_;
	    }
	    my ( $file, @err );
	    open( $file, "<", \$reqold) ||
	      $log->cc( pr => 'err',
			fm => "Cannot open data from variable to read ldif: %s",
			ls => [ $! ] );
	    $ldif = Net::LDAP::LDIF->new( $file, "r", onerror => 'warn' );
	    while ( not $ldif->eof ) {
	      $entry = $ldif->read_entry;
	      $log->cc( pr => 'err', fm => "Reading LDIF error: %s",
			ls => [ $ldif->error ] ) if $ldif->error;
	    }
	    $obj = $entry;
	    $ldif->done;
	  } elsif ( $entry->get_value('reqType') eq 'modify' ) {
	    ### here we re-assemble $obj to have all attributes before deletion
	    ### and since after that it'll has ctrl_attr but reqType=delete,
	    ### it'll go to $st == LDAP_SYNC_DELETE
	    %reqmod = map  { substr($_, 0, -2) => 1 } grep { /^(.*):-$/g }
	      @{$entry->get_value('reqMod', asref => 1)};

	    $mesg = $ldap->search( base   => $obj->dn,
				   scope  => 'base',
				   filter => '(objectClass=*)', );
	    if ( $mesg->code ) {
	      $log->cc( pr => 'err',
			fm => "LDAP search %s %s error:\n% 13s%s\n% 13s%s\n% 13s%s\n\n",
			ls => [
			       SYNST->[$st], 'reqType=modify',
			       'base: ',     $cf->get(qw(ldap srch log_base)),
			       'scope: ',    'sub',
			       'filter: ',   '(reqDN=' . $obj->dn . ')' ] );
	      $log->cc_ldap_err( mesg => $mesg );
	      # exit $mesg->code; # !!! NEED TO DECIDE WHAT TO DO
	    } else {
	      $obj = $mesg->entry(0);
	      $obj->add( map { $_ => $reqmod{$_} } keys %reqmod );
	      # $obj->add( $_ => $reqmod{$_} ) foreach ( keys %reqmod );
	    }
	    $log->cc( pr => 'debug', fm => "%s reqType=modify reqMod: %s",
		      ls => [ SYNST->[$st], \%reqmod ] )	if $v > 3;
	  }
	}
      } elsif ( $st == LDAP_SYNC_MODIFY ) {
	$mesg = $ldap->search( base     => $cf->get(qw(ldap srch log_base)),
			       scope    => 'sub',
			       sizelimit=> $cf->get(qw(ldap srch sizelimit)),
			       timelimit=> $cf->get(qw(ldap srch timelimit)),
			       filter   => '(reqDN=' . $obj->dn . ')', );
	if ( $mesg->code ) {
	  $log->cc( pr => 'err',
		    fm => "LDAP accesslog search on %s, error:\n% 13s%s\n% 13s%s\n% 13s%s\n\n",
		    ls => [ SYNST->[$st],
			    'base: ',   $cf->get(qw(ldap srch log_base)),
			    'scope: ',  'sub',
			    'filter: ', '(reqDN=' . $obj->dn . ')' ] );
	  $log->cc_ldap_err( mesg => $mesg );
	} else {
	  ### if modified object has no accesslog records, it means it was ModRDN-ed
	  ### so, we search for accesslog object with reqNewRDN=<$obj->dn RDN> to know
	  ### old object RDN to use it further for $out_file
	  if ( $mesg->count == 0 ) {
	    $mesg = $ldap->search( base     => $cf->get(qw(ldap srch log_base)),
				   scope    => 'sub',
				   sizelimit=> $cf->get(qw(ldap srch sizelimit)),
				   timelimit=> $cf->get(qw(ldap srch timelimit)),
				   filter   => '(reqNewRDN=' . (split(/,/, $obj->dn))[0] . ')', );
	    if ( $mesg->code ) {
	      $log->cc( pr => 'err',
			fm => "LDAP accesslog search on %s, error:\n% 13s%s\n% 13s%s\n% 13s%s\n\n",
			ls => [ SYNST->[$st],
				'base: ',   $cf->get(qw(ldap srch log_base)),
				'scope: ',  'sub',
				'filter: ', '(reqNewRDN=' . (split(/,/, $obj->dn))[0] . ')' ] );
	      $log->cc_ldap_err( mesg => $mesg );
	      # exit $mesg->code; # !!! NEED TO DECIDE WHAT TO DO
	    } else {
	      $entry = $mesg->entry(0);
	      $rdn_re = qr/^$rdn: .*$/;
	      foreach ( @{$entry->get_value('reqOld', asref => 1)} ) {
		$rdn_old = (split(/: /, $_))[1] if /$rdn_re/;
	      }
	      %out_paths = out_paths( cf => $cf, obj => $obj, s => $s,
				      rdn => $rdn, rdn_val => $rdn_old );
	      return if ! %out_paths;
	      $out_file_pfx_old = $out_paths{out_file_pfx} if exists $out_paths{out_file_pfx};
	      $out_file_old     = $out_paths{out_file}     if exists $out_paths{out_file};
	    }
	  }
	}
      }

      if ( ! defined $s ) {
	$log->cc( pr => 'warning',
		  fm => "dn: %s is not configured to be processed on control: %s",
		  ls => [ $obj->dn, SYNST->[$st] ] )
	  if $v > 2;
	return;
      }

      ### PREPARING OUTPUT RELATED VARIABLES
      %out_paths = out_paths( cf => $cf, obj => $obj, s => $s, rdn => $rdn );
      return if ! %out_paths;
      $out_file_pfx = $out_paths{out_file_pfx} if exists $out_paths{out_file_pfx};
      $out_file     = $out_paths{out_file}     if exists $out_paths{out_file};

      $dir = $out_file_pfx // $cf->get('service', $s, 'out_path');

      $log->cc( pr => 'debug', fm => "output directory: %s; file: %s",
		ls => [ $dir, $out_file ] )	if $v > 2;

      # NEED TO AJUST TO ctrl_attr array topology
      # $log->cc( pr => 'debug',
      # 	     fm => sprintf("SERVICE PREPROCESSING: % 8s; is-there-control-attribute( % 36s) = % 6s; DN: %s",
      # 			   $s,
      # 			   $cf->get('service', $s, 'ctrl_attr'),
      # 			   $obj->exists($cf->get('service', $s, 'ctrl_attr')) ? 'TRUE' : 'FALSE',
      # 			   $obj->dn) )
      #   if $v > 3;

      #@#@#@#@#@#@##@#@#@#@#@#@##@#@#@#@#@#@##@#@#@#@#@#@##@#@#@#@#@#@##@#@#@#@#@#@#
      #@#@#@#@#@#@# >>>>>>>>> 1
      #@#@#@#@#@#@##@#@#@#@#@#@##@#@#@#@#@#@##@#@#@#@#@#@##@#@#@#@#@#@##@#@#@#@#@#@#
      if ( $st == LDAP_SYNC_ADD || $st == LDAP_SYNC_MODIFY ) {

	if ( defined $out_file_old ) {
	  if ( unlink $dir . '/' . $out_file_old ) {
	    $log->cc( pr => 'info', fm => "file %s deleted (after ModRDN)",
		      ls => [ $dir . '/' . $out_file_old ] );
	  } else {
	    $log->cc( pr => 'err', fm => "%s not removed (after ModRDN); error: %s",
		      ls => [ $dir . '/' . $out_file_old, $! ] );
	  }
	}

	### COLLECTING ALL MAPPED ATTRIBUTES VALUES
	foreach my $i ( ( 'm', 's') ) {
	  if ( $cf->is_section('service', $s, 'map', $i) ) {
	    foreach my $j ( $cf->names_of('service', $s, 'map', $i) ) {
	      if ( $i eq 's' && ! $obj->exists( $cf->get('service', $s, 'map', $i, $j)) ) {
		if ( $cf->get(qw(core dryrun)) ) {
		  $log->cc( pr => 'debug', fm => "DRYRUN: %s to be deleted (no attribute: %s)",
			    ls => [ $dir . '/' . $out_file,
				    $cf->get('service', $s, 'map', $i, $j) ] );
		} else {
		  if ( unlink $dir . '/' . $out_file ) {
		    $log->cc( pr => 'debug', fm => "file %s deleted (no attribute: %s)",
			      ls => [ $dir . '/' . $out_file,
				      $cf->get('service', $s, 'map', $i, $j) ] )
		      if $v > 0;
		  } else {
		    $log->cc( pr => 'err', fm => "%s not removed (no attribute: %s); error: ",
			      ls => [ $dir . '/' . $out_file,
				      $cf->get('service', $s, 'map', $i, $j),
				      $! ] );
		  }
		}

		### if any of `map s` attributes doesn't exist, we delete that config file
		### preliminaryly and skip that attribute from been processed by Template
		next;

	      } elsif ( $i eq 'm' && $obj->exists( $cf->get('service', $s, 'map', $i, $j)) ) {
		$tt_vars->{$j} = $obj->get_value( $cf->get('service', $s, 'map', $i, $j),
						  asref => 1 );
	      } else {
		if ( $j =~ /certificateRevocationList/ ) {
		  $tt_vars->{$j} =
		    opensslize({ in => $obj->get_value( $cf->get('service', $s, 'map', $i, $j) ) });
		} elsif ( $j =~ /cACertificate/ ) {
		  $tt_vars->{$j} =
		    opensslize({ cmd => 'x509', in => $obj->get_value( $cf->get('service', $s, 'map', $i, $j) ) });
		} else {
		  $tt_vars->{$j} = $obj->get_value( $cf->get('service', $s, 'map', $i, $j) ) // 'NA';
		}
	      }
	    }
	  }
	}
	$tt_vars->{prog}       = sprintf("%s v.%s", $PROGNAM, $VERSION);
	$tt_vars->{DN}         = $obj->dn;
	$tt_vars->{date}       = strftime( $ts_fmt, localtime(time));
	$tt_vars->{descr}      = $obj->get_value('description')
	  if $obj->exists('description');
	$tt_vars->{server}     = ( split(/\@/, $obj->get_value('authorizedService')) )[1]
	  if $obj->exists('authorizedService');
	$tt_vars->{createdby}  =
	  ( split(/=/, ( split(/,/, $obj->get_value('creatorsName')) )[0]) )[1];
	$tt_vars->{modifiedby} =
	  ( split(/=/, ( split(/,/, $obj->get_value('modifiersName')) )[0]) )[1];

	if ( ! $force && -e $dir . '/' . $out_file &&
	     ( generalizedTime_to_time($obj->get_value('modifyTimestamp'))
	       <
	       (stat($dir . '/' . $out_file))[9] ) ) {
	  $log->cc( pr => 'debug',
		    fm => "skip. object %s is older than target file %s, (object modifyTimestamp: %s is older than file mtime: %s",
		    ls => [ $obj->dn, $dir . '/' . $out_file,
			    strftime( "%F %T",
				      localtime(generalizedTime_to_time($obj->get_value('modifyTimestamp')))),
			    strftime( "%F %T", localtime((stat($dir . '/' . $out_file))[9])),
			  ] )
	    if $v > 0;
	  return;
	}

	### PICKING ROOT OBJECT RDN (IN OUR CASE IT IS "UID")
	foreach ( reverse split(/,/, $obj->dn) ) {
	  next if $_ !~ /^uid=/;
	  $tt_vars->{uid} = ( split(/=/, $_) )[1];
	  last;
	}

	### DRYRUN
	if ( $cf->get(qw(core dryrun)) ) {

	  $log->cc( pr => 'debug', fm => "DRYRUN: %s -> %s",
		    ls => [
			   sprintf("%s/%s", $cf->get(qw(core tt_path)),
				   $cf->get('service', $s, 'tt_file')),
			   $dir. '/' . $out_file
			  ] );

	  if ( $cf->is_set($s, 'chmod') ) {
	    $log->cc( pr => 'err', fm => "DRYRUN: chmod %s, %s",
		      ls => [ $cf->get('service', $s, 'chmod'), $dir . '/' . $out_file ] );
	  } elsif ( $cf->is_set(qw(core chmod)) ) {
	    $log->cc( pr => 'err', fm => "DRYRUN: chmod %s, %s",
		      ls => [ $cf->get('core', 'chmod'), $dir . '/' . $out_file ] );
	  }

	  if ( $cf->is_set($s, 'chown') ) {
	    $log->cc( pr => 'err', fm => "DRYRUN: chown %s, %s, %s",
		      ls => [ $obj->get_value('uidNumber'),
			      $obj->get_value('gidNumber'),
			      $dir . '/' . $out_file ] );
	  }
	  return;
	}

	my ( $tmp_fh, $tmp_fn );
	eval { $tmp_fh = File::Temp->new( UNLINK => 0, DIR => $dir ); };
	if ( $@ ) {
	  $log->cc( pr => 'err', fm => "File::Temp->new( DIR => %s ); service \"%s\"; err: \"%s\"",
		    ls => [ $dir, $s, $@ ] );
	  return;
	}
	$tmp_fn = $tmp_fh->filename;
	my $tt = Template->new( TRIM        => $cf->get(qw(core tt_trim)),
				ABSOLUTE    => 1,
				RELATIVE    => 1,
				OUTPUT_PATH => $dir,
				DEBUG       => $fg // $cf->get(qw(core tt_debug)) );

	$log->cc( pr => 'err', fm => "Template->new( OUTPUT_PATH => %s ) for service %s error: %s",
		  ls => [ $dir, $s, $! ] )
	  if ! defined $tt;

	$tt->process( sprintf("%s/%s",
			      $cf->get(qw(core tt_path)),
			      $cf->get('service', $s, 'tt_file')),
		      $tt_vars,
		      $tmp_fh ) || do {
			$log->cc( pr => 'err', fm => "%s .tt process error: %s",
				  ls => [ SYNST->[$st], $tt->error ] );
			return;
		      };

	close( $tmp_fh ) || do {
	  $log->cc( pr => 'err', fm => "close file (opened for writing), service %s, failed: %s",
		    ls => [ $s, $! ] );
	  next;
	};

	if ( $cf->get(qw(core dryrun)) ) {
	  $log->cc( pr => 'debug', fm => "DRYRUN: rename %s should be renamed to %s",
		    ls => [ $tmp_fn, $out_file ] );
	} else {
	  rename $tmp_fn, $dir . '/' . $out_file ||
	    $log->cc( pr => 'err', fm => "rename %s to %s, failed",
		      ls => [ $tmp_fn, $dir . '/' . $out_file ] );

	  if ( -e $dir . '/' . $out_file ) {
	    if ( $cf->is_set('service', $s, 'chmod') ) {
	      chmod oct($cf->get('service', $s, 'chmod')), $dir . '/' . $out_file ||
		$log->cc( pr => 'err', fm => "chmod for %s failed",
			  ls => [ $dir . '/' . $out_file ] );
	    } elsif ( $cf->is_set(qw(core chmod)) ) {
	      chmod oct($cf->(qw(core chmod))), $dir . '/' . $out_file ||
		$log->cc( pr => 'err', fm => "chmod for %s failed",
			  ls => [ $dir . '/' . $out_file ] );
	    }

	    if ( $cf->is_set('service', $s, 'chown') ) {
	      chown $obj->get_value('uidNumber'),
		$obj->get_value('gidNumber'),
		$dir . '/' . $out_file ||
		$log->cc( pr => 'err', fm => "chown ($s:$s) %s failed",
			  ls => [ $obj->get_value('uidNumber'),
				  $obj->get_value('gidNumber'),
				  $dir . '/' . $out_file ] );
	    }
	  } else {
	    $log->cc( pr => 'err', fm => "%s disappeared, no such file any more...",
		      ls => [ $dir . '/' . $out_file ] );
	  }
	}
	$log->cc( pr => 'debug', fm => "control %s: dn: %s processed successfully.",
		  ls => [ SYNST->[$st], $obj->dn ] );

	#@#@#@#@#@#@##@#@#@#@#@#@##@#@#@#@#@#@##@#@#@#@#@#@##@#@#@#@#@#@##@#@#@#@#@#@#
	#@#@#@#@#@#@# >>>>>>>>> 2
	#@#@#@#@#@#@##@#@#@#@#@#@##@#@#@#@#@#@##@#@#@#@#@#@##@#@#@#@#@#@##@#@#@#@#@#@#
      } elsif ( $st == LDAP_SYNC_DELETE ) {
	if ( $cf->get(qw(core dryrun)) ) {
	  $log->cc( pr => 'debug', fm => "DRYRUN: file %s should be deleted",
		    ls => [ $dir . '/' . $out_file ] );
	} else {
	  if ( unlink $dir . '/' . $out_file ) {
	    $log->cc( pr => 'debug', fm => "file %s was successfully deleted",
		      ls => [ $dir . '/' . $out_file ] )
	      if $v > 0;
	  } else {
	    $log->cc( pr => 'err', fm => "file %s was not removed; error: ",
		      ls => [ $dir . '/' . $out_file, $! ] );
	  }
	}
	$log->cc( pr => 'debug', fm => "control %s: dn: %s processed successfully..",
		  ls => [ SYNST->[$st], $obj->dn ] );
      }
    } elsif ( defined $syncstate && $syncstate->isa('Net::LDAP::Control::SyncDone') ) {
      $log->cc( pr => 'debug', fm => "Received SYNC DONE CONTROL" ) if $v > 1;
    } elsif ( ! defined $syncstate ) {
      $log->cc( pr => 'warning', fm => "LDAP entry without Sync State control" ) if $v > 1;
    }

    $req->cookie($syncstate->cookie) if $syncstate->cookie;
  
  } elsif ( defined $obj && $obj->isa('Net::LDAP::Intermediate') ) {
    $log->cc( pr => 'debug', fm => "Received Net::LDAP::Intermediate\n%s", ls => [ $obj ] )
      if $v > 3;
    $req->cookie($obj->{'asn'}->{'refreshDelete'}->{'cookie'});
  } elsif ( defined $obj && $obj->isa('Net::LDAP::Reference') ) {
    $log->cc( pr => 'debug', fm => "Received Net::LDAP::Reference\n%s", ls => [ $obj ] )
      if $v > 3;
    return;
  } else {
    return;
  }
}

sub out_paths {
  local %_ = @_;
  my $arg = { cf      => $_{cf},
	      obj     => $_{obj},
	      s       => $_{s},
	      rdn     => $_{rdn},
	      rdn_val => $_{rdn_val} // $_{obj}->get_value($_{rdn}), };
  my ($out_file_pfx, $out_file);
  if ( $arg->{cf}->is_set('service', $arg->{s}, 'out_file_pfx') &&
       $arg->{cf}->is_set('service', $arg->{s}, 'out_file') ) {
    $out_file_pfx = $arg->{obj}->get_value($arg->{cf}->get('service', $arg->{s}, 'out_file_pfx'));
    $out_file_pfx = substr($out_file_pfx, 1) if $arg->{cf}->is_set(qw(core altroot));
    if ( ! -d $out_file_pfx ) {
      $log->cc( pr => 'err', fm => "service %s, target directory %s doesn't exist",
		ls => [ $arg->{s}, $out_file_pfx ] );
      return ();
    } else {
      $out_file = sprintf("%s%s", $arg->{cf}->get('service', $arg->{s}, 'out_file'),
			  $arg->{cf}->get('service', $arg->{s}, 'out_ext') // '');
    }
  } elsif ( ! $arg->{cf}->is_set('service', $arg->{s}, 'out_file_pfx') &&
	    $arg->{cf}->is_set('service', $arg->{s}, 'out_file')) {
    $out_file = sprintf("%s%s", $arg->{cf}->get('service', $arg->{s}, 'out_file'),
			$arg->{cf}->get('service', $arg->{s}, 'out_ext') // '');
  } elsif ( ! $arg->{cf}->is_set('service', $arg->{s}, 'out_file_pfx') &&
	    ! $arg->{cf}->is_set('service', $arg->{s}, 'out_file')) {
    $out_file = sprintf("%s%s", $arg->{rdn_val},
			$arg->{cf}->get('service', $arg->{s}, 'out_ext') // '');
  }

  return ( out_file_pfx => $out_file_pfx, out_file => $out_file );
}

sub opensslize {
  my $args = shift;
  my $arg = { cmd     => $args->{cmd}     // 'crl',
	      in      => $args->{in},
	      inform  => $args->{inform}  // 'DER',
	      outform => $args->{outform} // 'PEM'
	    };

  my ( $chin, $chou );
  my $pid = open2($chou, $chin,
		  '/usr/bin/openssl', $arg->{cmd}, '-inform', $arg->{inform}, '-outform', $arg->{outform});

  print $chin $arg->{in};
  waitpid( $pid, 0 );
  my $chst = $? >> 8;
  if ( $chst ) {
    $log->cc( pr => 'err',
	      fm => "opensslize() error!" ) if $v > 1;
  }
  ;

  $arg->{res} .= $_ while ( <$chou> );

  return $arg->{res};
}

__END__

=head1 NAME

regather - syncrepl consumer to perform action desired on
syncrepl event.

=head1 SYNOPSIS

regather [-h|--help|-? -F] <-c regather.conf> [ -C section.option=value, ... ]

=head1 DESCRIPTION

I<regather> is a syncrepl consumer to generate ( B<re-gather> ) files
on LDAP synrepl events or even more, it can perform any action you set (like
create/delete directories or other).

It uses L<Net::LDAP> to do all LDAP related stuff and L<Template> to
generate files. Config file is processed with L<Config::Parser> (look
B<CONFIG FILE> section bellow)

As an example, regather will re-write each OpenVPN client config file on
change, or re-write CRL file on update in LDAP or change sieve script
for mail user.

I<regather> is configured via it's configuration file. Each
configuration option can be overidden via CLI options like I<-C
section.subsection.subsubsection.option=value>

I<regather> connects to LDAP I<ldap.opt.uri> configured and performs
search with I<ldap.srch.filter> which B<has to provide search result
for all> configured I<service>s

Search results are used to provide data for Template(3) to:

- write target file, using configured I<core.tt_path/service.XXX.tt_file>

- manipulate with service/s directory/ies

- to be continued...

=head1 OPERATIONS

On LDAP repl event, consumer receives syncstate, we process these three:

    LDAP_SYNC_ADD
    LDAP_SYNC_MODIFY
    LDAP_SYNC_DELETE

on LDAP_SYNC_ADD and LDAP_SYNC_MODIFY we just overwrite all configured
for the service things (files, directories e.t.c.)

LDAP_SYNC_DELETE differs a bit, it can be spawned by deletion of LDAP
object itself or by deletion of some attribute of the object. So, on that
event we restore previous state of the object from accesslog DB (which
is mandatory for our work) and look at the attribute reqType value. 

There are two cases we take care of:

=over 4

=item I<reqType = delete>

this is the deletion of the whole object and we destroy all related
stuff, configured for that service.

=item I<reqType = modify>

this is the deletion of an attribute and we need to know whether it
was I<ctrl_attr> one (look B<CONFIG FILE> section bellow). If it is,
then we destroy all related stuff, configured in service.

=back

=head1 OPTIONS

=over 4

=item B<-c | --config>

config file (mandatory)

=item B<-f | --foreground>

run in foreground (optional)

=item B<-F | --forece>

force re-generation of resources configured regardless existent file mtime and
LDAP object modifiedTimestamp

=item B<-S | --strict>

exit on serverside LDAP errors (connection, server restart, etc). If
not set, B<regather> will try connect infinetely. (default: not set)

=item B<--colors>

terminal colors are used in foreground debug output. (optional)

=item B<-C | --cli> section.option = value

CLI equivalent to config file options. (optional, can be multiple)

for example I<core.dryrun=1> (for full list of options available see Regather::Conf(3))

=item B<--config-help>

print config file lexicon (require option I<-c>, set)

=item B<-v>

verbosity (optional, incremental)

=item B<-h | --help>

help page

=item B<--version>

shows version

=back

=head1 USAGE

regather <-c regather.conf> [ all other options ]

=head1 FILES

    /usr/local/etc/regather.d/*.tt templates to generate files from
    /usr/local/etc/regather.conf   config file

    /usr/local/etc/openldap/ldap.conf
    /etc/ldap.conf
    /etc/ldap/ldap.conf
    /etc/openldap/ldap.conf

=head1 CONFIG FILE

config file format is described in L<Regather::Config> documentation.

=head1 SIGNALS

HUP - restart

INT, QUIT, ABRT, TERM - terminate


=head1 SEE ALSO

L<Net::LDAP>,
L<Template>,
L<Regather::Config>

=head1 AUTHOR

Zeus Panchenko E<lt>zeus@gnu.org.uaE<gt>

=head1 COPYRIGHT

Copyright 2019 Zeus Panchenko.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

=cut
