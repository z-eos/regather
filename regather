#!/usr/bin/env perl
# -*- mode: cperl; mode: follow; -*-
#

use strict;
use warnings;
use diagnostics;
use Pod::Usage qw(pod2usage);
use POSIX;
use Template;
use Sys::Syslog qw(:standard :macros);
use Getopt::Long qw(:config no_ignore_case gnu_getopt auto_version);
use List::Util qw( uniqstr );
use IPC::Open2;
use File::Temp;
use File::Basename;

use Regather::Config;
use Regather::Logg;

use Net::LDAP;
use Net::LDAP::LDIF;
use Net::LDAP::Constant qw( LDAP_SYNC_REFRESH_ONLY
			    LDAP_SYNC_REFRESH_AND_PERSIST
			    LDAP_SUCCESS
			    LDAP_SYNC_PRESENT
			    LDAP_SYNC_ADD
			    LDAP_SYNC_MODIFY
			    LDAP_SYNC_DELETE
			    LDAP_CONNECT_ERROR
			    LDAP_OPERATIONS_ERROR
			    LDAP_LOCAL_ERROR
			 );
use Net::LDAP::Control::SyncRequest;

use constant SYNST => [ qw( LDAP_SYNC_PRESENT LDAP_SYNC_ADD LDAP_SYNC_MODIFY LDAP_SYNC_DELETE ) ];

my @DAEMONARGS = ($0, @ARGV);
my $PROGNAM    = fileparse($0);
my $VERSION    = '0.65';

my $LL = [ qw( emerg alert crit err warning notice info debug ) ];
my $ts_fmt = "%a %F %T %Z (%z)";

our $v            = 0;
our $fg           = 0;
my $colors        = 0;
my $config        = '/usr/local/etc/regather.conf';
my $cli;
my $ch;

my $get_opt_res =
  GetOptions(
	     'f|foreground' => \$fg,
	     'c|config=s'   => \$config,
	     'colors'       => \$colors,
	     'C|cli=s%'     => \$cli,
	     'config-help'  => \$ch,
	     'v+'           => \$v,
	     'h'            => sub { pod2usage(-exitval => 0, -verbose => 2); exit 0 },
	    );

my $log = new Regather::Logg( prognam    => $PROGNAM,
			      foreground => $fg,
			      colors     => $colors );
$log->logg({ pr => 'info', fm => "Regather::Logg initialized ..." }) if $v > 1;

$log->logg({ pr => 'info', fm => "options provided from CLI:\n%s", ls => [ $cli ] })
  if keys( %{$cli} ) && $v > 1;

my $cf = new Regather::Config ( filename  => $config,
			        logger    => $log,
				cli       => $cli,
			        # add_nodes => { ldap_old => $ldap_opts },
				verbose   => $v );

if ( ! defined $cf ) {
  $log->logg({ pr => 'err', fm => "do fix config file ..." });
  pod2usage(-exitval => 2, -sections => [ qw(USAGE) ]);
  exit 1;
}

if ( $ch ) {
  $cf->config_help;
  exit 1;
}

$log->set_m( $cf->getnode('log')->as_hash );

$log->logg({ pr => 'info', fm => "Dry Run is set on, no file is to be changed\n" })
  if $cf->get(qw(core dryrun));
$log->logg({ pr => 'info', fm => "Config::Parse object as hash:\n%s",
	     ls => [ $cf->as_hash ] }) if $v > 2;
$log->logg({ pr => 'info', fm => "%s v.%s is starting ...",
	     ls => [ $PROGNAM, $VERSION ] });

our @svc = $cf->names_of('service');

daemonize() if ! $fg;

my $req = Net::LDAP::Control::SyncRequest->new( mode     => LDAP_SYNC_REFRESH_AND_PERSIST,
						critical => 1,
						cookie   => undef, );

our $s;
our $ldap;
my $tmp;
our $cfgattrs = [];
my $mesg;
my @svc_map;

foreach my $i ( @svc ) {
  foreach ( qw( s m ) ) {
    if ( $cf->is_section('service', $i, 'map', $_) ) {
      @svc_map = values( %{ $cf->getnode('service', $i, 'map', $_)->as_hash } );
      $cfgattrs = [ @{$cfgattrs}, @svc_map ];
    } else {
      @svc_map = ();
    }
  }
}

my @sysattrs = qw( authorizedService
		   description
		   entryUUID
		   entryCSN
		   createTimestamp
		   creatorsName
		   modifiersName
		   modifyTimestamp );
@{$tmp}   = uniqstr @{$cfgattrs};
$cfgattrs = [ @{$tmp}, @sysattrs, ];

#
## -=== MAIN LOOP =====================================================-
#
my $ldap_opt      = $cf->getnode(qw(ldap opt))->as_hash;
my $uri           = delete $ldap_opt->{uri};
our $last_forever = 1;
while ( $last_forever ) {
  if ( $cf->is_set(qw(core altroot)) ) {
    chdir($cf->get(qw(core altroot))) || do {
      $log->{logger}->logg({ pr => 'err', fm => "main: unable to chdir to %s",
			     ls => [ $cf->get(qw(core altroot)) ] });
      exit 1;
    };
  }

  $ldap = Net::LDAP->new( $uri,
			  @{[ map { $_ => $ldap_opt->{$_} } %$ldap_opt ]} ) || do {
    print "\nUnable to connect to $cf->get(qw(ldap opt uri)): $!\n\n";
    exit LDAP_CONNECT_ERROR;
  };

  my $start_tls_options = $cf->getnode(qw(ldap ssl))->as_hash;
  if ( exists $start_tls_options->{ssl} && $start_tls_options->{ssl} eq 'start_tls' ) {
    delete $start_tls_options->{ssl};
    eval {
      $mesg =
	$ldap->start_tls( @{[ map { $_ => $start_tls_options->{$_} } %$start_tls_options ]} );
    };
    if ( $@ ) {
      $log->logg({ pr => 'err', fm => "TLS negotiation failed: %s", ls => [ $! ] });
      exit LDAP_CONNECT_ERROR;
    } else {
      $log->logg({ pr => 'info', fm => "TLS negotiation succeeded" }) if $v > 1;
    }
  }

  my $bind = $cf->getnode(qw(ldap bnd))->as_hash;
  if ( ref($bind) eq 'HASH' ) {
    if ( exists $bind->{dn} ) {
      my @bind_options;
      push @bind_options, delete $bind->{dn};
      while ( my($k, $v) = each %{$bind} ) {
	push @bind_options, $k => $v;
      }
      $mesg = $ldap->bind( @bind_options );
      if ( $mesg->code ) {
	$log->logg({ pr => 'err', fm => "bind error: %s", ls => [ $mesg->error ] });
	exit $mesg->code;
      }
    }
  }


  $mesg = $ldap->search( base     => $cf->get(qw(ldap srch base)),
			 scope    => $cf->get(qw(ldap srch scope)),
			 control  => [ $req ],
			 callback => \&ldap_search_callback,
			 filter   => $cf->get(qw(ldap srch filter)),
			 attrs    => $cfgattrs,
			 sizelimit=> $cf->get(qw(ldap srch sizelimit)),
			 timelimit=> $cf->get(qw(ldap srch timelimit)),
		       );
  if ( $mesg->code ) {
    $log->logg({ pr => 'err',
		 fm => "LDAP search ERROR...\n% 13s%s\n% 13s%s\n% 13s%s\n% 13s%s\n\n",
		 ls => [
			'base: ',         $cf->get(qw(ldap srch base)),
			'scope: ',        $cf->get(qw(ldap srch scope)),
			'filter: ',       $cf->get(qw(ldap srch filter)),
			'attrs: ',        join("\n", @{$cfgattrs}) ] });
    $log->logg_ldap_err({ mesg => $mesg });
    exit $mesg->code;
  } else {
    $log->logg({ pr => 'info',
		 fm => "LDAP search:\n% 13s%s\n% 13s%s\n% 13s%s\n% 13s%s\n\n",
		 ls => [ 'base: ',   $cf->get(qw(ldap srch base)),
			 'scope: ',  $cf->get(qw(ldap srch scope)),
			 'filter: ', $cf->get(qw(ldap srch filter)),
			 'attrs: ',  join("\n", @{$cfgattrs}) ] }) if $v > 2;
  }
}

closelog();

$mesg = $ldap->unbind;
if ( $mesg->code ) {
  $log->logg_ldap_err({ mesg => $mesg });
  exit $mesg->code;
}

exit 0;

#
## ===================================================================
#

sub daemonize {
  my ( $pid, $fh, $pp, $orphaned_pid_mtime );
  if ( -e $cf->get(qw(core pid_file)) ) {
    open( $fh, "<", $cf->get(qw(core pid_file))) || do {
      die "Can't open $cf->get(qw(core pid_file)) for reading: $!";
      exit 1;
    };
    $pid = <$fh>;
    close($fh) || do {
      print "close $cf->get(qw(core pid_file)) (opened for reading) failed: $!\n\n";
      exit 1;
    };

    if ( kill(0, $pid) ) {
      print "Doing nothing\npidfile $cf->get(qw(core pid_file)) of the proces with pid $pid, exists and the very process is alive\n\n";
      exit 1;
    }

    $orphaned_pid_mtime = strftime( $ts_fmt, localtime( (stat( $cf->get(qw(core pid_file)) ))[9] ));
    if ( unlink $cf->get(qw(core pid_file)) ) {
      $log->logg({ pr => 'debug', fm => "orphaned %s was removed",
	     ls => [ $cf->get(qw(core pid_file)) ] })
	if $v > 0;
    } else {
      $log->logg({ pr => 'err', fm => "orphaned %s (mtime: %s) was not removed: %s",
	     ls => [ $cf->get(qw(core pid_file)), $orphaned_pid_mtime, $! ] });
      exit 2;
    }

    undef $pid;
  }

  $pid = fork();
  die "fork went wrong: $!\n\n" unless defined $pid;
  exit(0) if $pid != 0;

  setsid || do { print "setsid went wrong: $!\n\n"; exit 1; };

  open( $pp, ">", $cf->get(qw(core pid_file))) || do {
    print "Can't open $cf->get(qw(core pid_file)) for writing: $!"; exit 1; };
  print $pp "$$";
  close( $pp ) || do {
    print "close $cf->get(qw(core pid_file)) (opened for writing), failed: $!\n\n"; exit 1; };

  if ( $v > 1 ) {
    open (STDIN,  "</dev/null") || do { print "Can't redirect /dev/null to STDIN\n\n"; exit 1; };
    open (STDOUT, ">/dev/null") || do { print "Can't redirect STDOUT to /dev/null\n\n"; exit 1; };
    open (STDERR, ">&STDOUT")   || do { print "Can't redirect STDERR to STDOUT\n\n"; exit 1; };
  }

  $SIG{HUP}  = sub { my $sig = @_;
		     $log->logg({ pr => 'warning', fm => "SIG $sig received, restarting" });
		     exec('perl', @DAEMONARGS); };
  $SIG{INT} = $SIG{QUIT} = $SIG{ABRT} = $SIG{TERM} =
    sub { my $sig = @_;
	  $log->logg({ pr => 'warning', fm => " SIG $sig received, exiting" });
	  $last_forever = 0;};
  $SIG{PIPE} = 'ignore';
  $SIG{USR1} = sub { my $sig = @_;
		     $log->logg({ pr => 'warning', fm => "SIG $sig received, doing nothing" }) };

  if ( $cf->is_set(qw(core uid)) && $cf->is_set(qw(core gid)) ) {
    setgid ( $cf->get(qw(core gid_number)) ) || do { print "setgid went wrong: $!\n\n"; exit 1; };
    setuid ( $cf->get(qw(core uid_number)) ) || do { print "setuid went wrong: $!\n\n"; exit 1; };
  }

  $log->logg({ pr => 'info', fm => "%s v.%s is started.", ls => [ $PROGNAM, $VERSION ] });
}

sub ldap_search_callback {
  my ( $msg, $obj ) = @_;

  my @controls = $msg->control;
  my $syncstate = scalar @controls ? $controls[0] : undef;

  my ( $s, $st, $tt_vars, $map, $out_file_pfx, $out_file, $tmp_debug_msg, $rdn, $dir );

  $log->logg({ pr => 'debug', fm => "syncstate: %s", ls => [ $syncstate ] })
    if $v > 4;
  $log->logg({ pr => 'debug', fm => "object: %s", ls => [ $obj ] }) if $v > 4;

  if ( defined $obj && $obj->isa('Net::LDAP::Entry') ) {
      $rdn = ( split(/=/, ( split(/,/, $obj->dn) )[0]) )[0];
      if ( defined $syncstate && $syncstate->isa('Net::LDAP::Control::SyncState') ) {
	$log->logg({ pr => 'debug', fm => "SYNCSTATE:\n%s:", ls => [ $syncstate ] })
	  if $v > 3;
	$st = $syncstate->state;
	my $ldif;
	my %reqmod;
	$log->logg({ pr => 'debug', fm => "%s: DN: %s", ls => [ SYNST->[$st], $obj->dn ] });

	### LDAP_SYNC_DELETE arrives for both, object deletetion and attribute deletion
	### in both cases Net::LDAP::Entry provided contains only DN, so, we need
	### to "re-construct" it for further processing
	if ( $st == LDAP_SYNC_DELETE ) {
	  my $mesg = $ldap->search( base     => $cf->get(qw(ldap srch log_base)),
				    scope    => 'sub',
				    sizelimit=> $cf->get(qw(ldap srch sizelimit)),
				    timelimit=> $cf->get(qw(ldap srch timelimit)),
				    filter   => '(reqDN=' . $obj->dn . ')', );
	  if ( $mesg->code ) {
	    $log->logg({ pr => 'err',
			 fm => "LDAP accesslog search on %s event error:\n% 13s%s\n% 13s%s\n% 13s%s\n\n",
			 ls => [
				SYNST->[$st],
				'base: ',         $cf->get(qw(ldap srch log_base)),
				'scope: ',        'sub',
				'filter: ',       '(reqDN=' . $obj->dn . ')' ] });
	    $log->logg_ldap_err({ mesg => $mesg });
	    # exit $mesg->code; # !!! NEED TO DECIDE WHAT TO DO
	  } else {
	    my $entry = pop @{[$mesg->sorted]};

	    if ( $entry->get_value('reqType') eq 'delete' ) {
	      my $reqold = 'dn: ' . $obj->dn;
	      foreach ( @{$entry->get_value('reqOld', asref => 1)} ) {
		s/^(.*;binary:) .*$/$1: c3R1Yg==/agis;
		$reqold .= "\n" . $_;
	      }
	      my ( $file, @err );
	      open( $file, "<", \$reqold) ||
		$log->logg({ pr => 'err',
			     fm => "Cannot open data from variable to rad ldif: %s",
			     ls => [ $! ] });
	      $ldif = Net::LDAP::LDIF->new( $file, "r", onerror => 'warn' );
	      while ( not $ldif->eof ) {
		$entry = $ldif->read_entry;
		$log->logg({ pr => 'err', fm => "Reading LDIF error: %s",
			     ls => [ $ldif->error ] }) if $ldif->error;
	      }
	      $obj = $entry;
	      $ldif->done;
	    } elsif ( $entry->get_value('reqType') eq 'modify' ) {
	      ### here we re-assemble $obj to have all attributes before deletion
	      ### and since after that it'll has ctrl_attr but reqType=delete,
	      ### it'll go to $st == LDAP_SYNC_DELETE
	      %reqmod =
		map  { substr($_, 0, -2) => 1 }
		grep { /^(.*):-$/g }
		@{$entry->get_value('reqMod', asref => 1)};

	      my $mesg = $ldap->search( base   => $obj->dn,
					scope  => 'base',
					filter => '(objectClass=*)', );
	      if ( $mesg->code ) {
		$log->logg({ pr => 'err',
			     fm => "LDAP search %s %s error:\n% 13s%s\n% 13s%s\n% 13s%s\n\n",
			     ls => [
				    SYNST->[$st],     'reqType=modify',
				    'base: ',         $cf->get(qw(ldap srch log_base)),
				    'scope: ',        'sub',
				    'filter: ',       '(reqDN=' . $obj->dn . ')' ] });
		$log->logg_ldap_err({ mesg => $mesg });
		# exit $mesg->code; # !!! NEED TO DECIDE WHAT TO DO
	      } else {
		$obj = $mesg->entry(0);
		$obj->add( map { $_ => $reqmod{$_} } keys %reqmod );
		# $obj->add( $_ => $reqmod{$_} ) foreach ( keys %reqmod );
	      }
	      $log->logg({ pr => 'debug', fm => "%s reqType=modify reqMod: %s",
			   ls => [ SYNST->[$st], \%reqmod ] })	if $v > 3;
	    }
	  }
	}

	foreach ( @svc ) {
	  $s = $_
	    if $obj->exists($cf->get('service', $_, 'ctrl_attr'));
	}

	### PREPARING OUTPUT RELATED VARIABLES
	if ( $cf->is_set('service', $s, 'out_file_pfx') &&
	     $cf->is_set('service', $s, 'out_file') ) {
	  $out_file_pfx = $obj->get_value($cf->get('service', $s, 'out_file_pfx'));
	  $out_file_pfx = substr($out_file_pfx, 1) if $cf->is_set(qw(core altroot));
	  if ( ! -d $out_file_pfx ) {
	    $log->logg({ pr => 'err', fm => "service %s, target directory %s doesn't exist",
			 ls => [ $s, $out_file_pfx ] });
	    next;
	  } else {
	    $out_file = sprintf("%s%s", $cf->get('service', $s, 'out_file'),
				$cf->get('service', $s, 'out_ext') // '');
	  }
	} elsif ( ! $cf->is_set('service', $s, 'out_file_pfx') &&
		  $cf->is_set('service', $s, 'out_file')) {
	  $out_file = sprintf("%s%s", $cf->get('service', $s, 'out_file'),
			      $cf->get('service', $s, 'out_ext') // '');
	} elsif ( ! $cf->is_set('service', $s, 'out_file_pfx') &&
		  ! $cf->is_set('service', $s, 'out_file')) {
	  $out_file = sprintf("%s%s", $obj->get_value($rdn),
			      $cf->get('service', $s, 'out_ext') // '');
	}

	$dir = $out_file_pfx // $cf->get('service', $s, 'out_path');

	$log->logg({ pr => 'debug', fm => "output directory: %s; file: %s",
		     ls => [ $dir, $out_file ] })	if $v > 2;
	$log->logg({ pr => 'debug',
		     fm => sprintf("SERVICE PREPROCESSING: % 8s; is-there-control-attribute( % 36s) = % 6s; DN: %s",
				   $s,
				   $cf->get('service', $s, 'ctrl_attr'),
				   $obj->exists($cf->get('service', $s, 'ctrl_attr')) ? 'TRUE' : 'FALSE',
				   $obj->dn) })
	  if $v > 3;

	if ( $st == LDAP_SYNC_ADD || $st == LDAP_SYNC_MODIFY ) { ### >>>>>>>>> 1

	  ### COLLECTING ALL MAPPED ATTRIBUTES VALUES
	  ### if any `map s` doesn't exist, we delete that config file
	  foreach my $i ( ( 'm', 's') ) {
	    if ( $cf->is_section('service', $s, 'map', $i) ) {
	      foreach my $j ( $cf->names_of('service', $s, 'map', $i) ) {
		if ( $i eq 's' && ! $obj->exists( $cf->get('service', $s, 'map', $i, $j)) ) {
		  if ( $cf->get(qw(core dryrun)) ) {
		    $log->logg({ pr => 'debug', fm => "DRYRUN: file %s should be deleted",
				 ls => [ $dir . '/' . $out_file ] });
		  } else {
		    if ( unlink $dir . '/' . $out_file ) {
		      $log->logg({ pr => 'debug', fm => "file %s was successfully deleted",
				   ls => [ $dir . '/' . $out_file ] })
			if $v > 0;
		    } else {
		      $log->logg({ pr => 'err', fm => "file %s was not removed; error: ",
				   ls => [ $dir . '/' . $out_file, $! ] });
		    }
		  }
		  next;
		} else {
		  if ( $j =~ /certificateRevocationList/ ) {
		    $tt_vars->{$j} =
		      opensslize({ in => $obj->get_value( $cf->get('service', $s, 'map', $i, $j) ) });
		  } else {
		    $tt_vars->{$j} = $obj->get_value( $cf->get('service', $s, 'map', $i, $j) ) // 'NA';
		  }
		}
	      }
	    }
	  }

	  $tt_vars->{prog}       = sprintf("%s v.%s", $PROGNAM, $VERSION);
	  $tt_vars->{DN}         = $obj->dn;
	  $tt_vars->{date}       = strftime( $ts_fmt, localtime(time));
	  $tt_vars->{descr}      = $obj->get_value('description')
	    if $obj->exists('description');
	  $tt_vars->{server}     = ( split(/\@/, $obj->get_value('authorizedService')) )[1]
	    if $obj->exists('authorizedService');
	  $tt_vars->{createdby}  =
	    ( split(/=/, ( split(/,/, $obj->get_value('creatorsName')) )[0]) )[1];
	  $tt_vars->{modifiedby} =
	    ( split(/=/, ( split(/,/, $obj->get_value('modifiersName')) )[0]) )[1];

	  ### PICKING ROOT OBJECT RDN (IN OUR CASE IT IS "UID")
	  foreach ( reverse split(/,/, $obj->dn) ) {
	    next if $_ !~ /^uid=/;
	    $tt_vars->{uid} = ( split(/=/, $_) )[1];
	    last;
	  }

	  ### DRYRUN
	  if ( $cf->get(qw(core dryrun)) ) {

	    $log->logg({ pr => 'debug', fm => "DRYRUN: %s -> %s",
			 ls => [
				sprintf("%s/%s", $cf->get(qw(core tt_path)),
					$cf->get('service', $s, 'tt_file')),
				$dir. '/' . $out_file
			       ] });

	    if ( $cf->is_set($s, 'chmod') ) {
	      $log->logg({ pr => 'err', fm => "DRYRUN: chmod %s, %s",
			   ls => [ $cf->get('service', $s, 'chmod'), $dir . '/' . $out_file ] });
	    } elsif ( $cf->is_set(qw(core chmod)) ) {
	      $log->logg({ pr => 'err', fm => "DRYRUN: chmod %s, %s",
			   ls => [ $cf->get('core', 'chmod'), $dir . '/' . $out_file ] });
	    }

	    if ( $cf->is_set($s, 'chown') ) {
	      $log->logg({ pr => 'err', fm => "DRYRUN: chown %s, %s, %s",
			   ls => [ $obj->get_value('uidNumber'),
				   $obj->get_value('gidNumber'),
				   $dir . '/' . $out_file ] });
	    }
	    next;
	  }

	  my ( $tmp_fh, $tmp_fn );
	  eval { $tmp_fh = File::Temp->new( UNLINK => 0, DIR => $dir ); };
	  if ( $@ ) {
	    $log->logg({ pr => 'err', fm => "File::Temp->new( DIR => %s ); service \"%s\"; err: \"%s\"",
			 ls => [ $dir, $s, $@ ] });
	    next;
	  }
	  $tmp_fn = $tmp_fh->filename;
	  my $tt = Template->new( TRIM        => 1,
				  ABSOLUTE    => 1,
				  RELATIVE    => 1,
				  OUTPUT_PATH => $dir,
				  DEBUG       => $fg // $cf->get(qw(core tt_debug)) );

	  $log->logg({ pr => 'err', fm => "Template->new( OUTPUT_PATH => %s ) for service %s error: %s",
		       ls => [ $dir, $s, $! ] })
	    if ! defined $tt;

	  $tt->process( sprintf("%s/%s",
				$cf->get(qw(core tt_path)),
				$cf->get('service', $s, 'tt_file')),
			$tt_vars,
			$tmp_fh ) || do {
			  $log->logg({ pr => 'err', fm => "%s .tt process error: %s",
				       ls => [ SYNST->[$st], $tt->error ] });
			  next;
			};

	  close( $tmp_fh ) || do {
	    $log->logg({ pr => 'err', fm => "close file (opened for writing), service %s, failed: %s",
			 ls => [ $s, $! ] });
	    next;
	  };

	  if ( $cf->get(qw(core dryrun)) ) {
	    $log->logg({ pr => 'debug', fm => "DRYRUN: rename %s should be renamed to %s",
			 ls => [ $tmp_fn, $out_file ] });
	  } else {
	    rename $tmp_fn, $dir . '/' . $out_file ||
	      $log->logg({ pr => 'err', fm => "rename %s to %s, failed",
			   ls => [ $tmp_fn, $dir . '/' . $out_file ] });

	    if ( -e $dir . '/' . $out_file ) {
	      if ( $cf->is_set($s, 'chmod') ) {
		chmod oct($cf->get('service', $s, 'chmod')), $dir . '/' . $out_file ||
		  $log->logg({ pr => 'err', fm => "chmod for %s failed",
			       ls => [ $dir . '/' . $out_file ] });
	      } elsif ( $cf->is_set(qw(core chmod)) ) {
		chmod oct($cf->(qw(core chmod))), $dir . '/' . $out_file ||
		  $log->logg({ pr => 'err', fm => "chmod for %s failed",
			       ls => [ $dir . '/' . $out_file ] });
	      }

	      if ( $cf->is_set($s, 'chown') ) {
		chown $obj->get_value('uidNumber'),
		  $obj->get_value('gidNumber'),
		  $dir . '/' . $out_file ||
		  $log->logg({ pr => 'err', fm => "chown ($s:$s) %s failed",
			       ls => [ $obj->get_value('uidNumber'),
				       $obj->get_value('gidNumber'),
				       $dir . '/' . $out_file ] });
	      }
	    } else {
	      $log->logg({ pr => 'err', fm => "%s disappeared, no such file any more...",
			   ls => [ $dir . '/' . $out_file ] });
	    }
	  }
	} elsif ( $st == LDAP_SYNC_DELETE ) { ### >>>>>>>>> 2
	  if ( $cf->get(qw(core dryrun)) ) {
	    $log->logg({ pr => 'debug', fm => "DRYRUN: file %s should be deleted",
			 ls => [ $dir . '/' . $out_file ] });
	  } else {
	    if ( unlink $dir . '/' . $out_file ) {
	      $log->logg({ pr => 'debug', fm => "file %s was successfully deleted",
			   ls => [ $dir . '/' . $out_file ] })
		if $v > 0;
	    } else {
	      $log->logg({ pr => 'err', fm => "file %s was not removed; error: ",
			   ls => [ $dir . '/' . $out_file, $! ] });
	    }
	  }
	}
      } elsif ( defined $syncstate && $syncstate->isa('Net::LDAP::Control::SyncDone') ) {
	$log->logg({ pr => 'debug', fm => "Received SYNC DONE CONTROL" }) if $v > 1;
      } elsif ( ! defined $syncstate ) {
	$log->logg({ pr => 'warning',
		     fm => "LDAP entry without Sync State control" }) if $v > 1;
      }

      $req->cookie($syncstate->cookie) if $syncstate->cookie;
  
    } elsif ( defined $obj && $obj->isa('Net::LDAP::Intermediate') ) {
    $req->cookie($obj->{'asn'}->{'refreshDelete'}->{'cookie'});
  } elsif ( defined $obj && $obj->isa('Net::LDAP::Reference') ) {
    return;
  } else {
    return;
  }
}

sub opensslize {
  my $args = shift;
  my $arg = { cmd     => $args->{cmd}     // 'crl',
	      in      => $args->{in},
	      inform  => $args->{inform}  // 'DER',
	      outform => $args->{outform} // 'PEM'
	    };

  my ( $chin, $chou );
  my $pid = open2($chou, $chin,
		  '/usr/bin/openssl', $arg->{cmd}, '-inform', $arg->{inform}, '-outform', $arg->{outform});

  print $chin $arg->{in};
  waitpid( $pid, 0 );
  my $chst = $? >> 8;
  if ( $chst ) {
    $log->logg({ pr => 'err',
	   fm => "opensslize() error!" }) if $v > 1;
  };

  $arg->{res} .= $_ while ( <$chou> );

  return $arg->{res};
}

__END__

=head1 NAME

I<regather> - syncrepl consumer to perform action desired on
syncrepl event.

=head1 SYNOPSIS

regather [-h|--help|-? -F] <-c regather.conf> [ -C section.option=value, ... ]

=head1 DESCRIPTION

I<regather> is a syncrepl consumer to generate ( B<re-gather> ) files
on LDAP synrepl events or even more, it can perform any action you set (like
create/delete directories or other).

It uses L<Net::LDAP> to do all LDAP related stuff and L<Template> to
generate files. Config file is processed with L<Config::Parser> (look
B<CONFIG FILE> section bellow)

As an example, regather will re-write each OpenVPN client config file on
change, or re-write CRL file on update in LDAP or change sieve script
for mail user.

I<regather> is configured via it's configuration file. Each
configuration option can be overidden via CLI options like I<-C
section.subsection.subsubsection.option=value>

I<regather> connects to LDAP I<ldap.opt.uri> configured and performs
search with I<ldap.srch.filter> which B<has to provide search result
for all> configured I<service>s

Search results are used to provide data for Template(3) to:

- write target file, using configured I<core.tt_path/service.XXX.tt_file>

- manipulate with service/s directory/ies

- to be continued...

=head1 OPTIONS

=over 4

=item B<-c | --config>

config file (mandatory)

=item B<-f | --foreground>

run in foreground (optional)

=item B<--colors>

terminal colors are used in foreground debug output. (optional)

=item B<-C | --cli> section.option = value

CLI equivalent to config file options. (optional, can be multiple)

for example I<core.dryrun=1> (for full list of options available see Regather::Conf(3))

=item B<--config-help>

print config file lexicon (require option I<-c>, set)

=item B<-v>

verbosity (optional, incremental)

=item B<-h | --help>

help page

=back

=head1 USAGE

regather <-c regather.conf> [ all other options ]

=head1 FILES

    /usr/local/etc/regather.d/*.tt templates to generate files from
    /usr/local/etc/regather.conf   config file

    /usr/local/etc/openldap/ldap.conf
    /etc/ldap.conf
    /etc/ldap/ldap.conf
    /etc/openldap/ldap.conf

=head1 CONFIG FILE

config file format is described in L<Regather::Config>

=head1 SEE ALSO

L<Net::LDAP>,
L<Template>,
L<Regather::Config>

=head1 AUTHOR

Zeus Panchenko E<lt>zeus@gnu.org.uaE<gt>

=head1 COPYRIGHT

Copyright (c) 2019 Zeus Panchenko. All rights reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

=cut
